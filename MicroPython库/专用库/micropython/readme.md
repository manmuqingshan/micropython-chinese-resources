# micropython（访问和控制MicroPython内部功能）

### 函数

- micropython.`const`(expr)

  用于声明某个表达式是常量，以便编译器对其进行优化。该函数的使用方法如下：

  ```py
  from micropython import const
  CONST_X = const(123)
  CONST_Y = const(2 * CONST_X + 1)
  ```

  通过这种方式声明的常量，仍可作为全局变量，在声明它们的模块外部被访问。如果常量名称以下划线开头，那它就是隐藏的，无法作为全局变量使用，而且在执行期间也不会占用任何内存。

  MicroPython 解析器能够直接识别这个 `const` 函数，它被作为 `micropython` 模块的一部分提供，主要目的是让脚本可以按照上述模式编写，从而在 CPython 和 MicroPython 环境下都能运行。
<br><br>

- micropython.`opt_level`( [ level ] )

  如果传入了 `level` 参数，该函数会为后续脚本的编译设置优化级别，并且返回 `None`；如果没有传入参数，就会返回当前的优化级别。

  优化级别对以下编译特性起控制作用：
  - 断言：在 0 级优化时，断言语句会被启用并编译到字节码中；在 1 级及更高优化级别时，断言语句则不会被编译。
  - 内置的 `__debug__` 变量：0 级优化时，这个变量会扩展为 `True`；在 1 级及更高优化级别时，它会扩展为 `False`。
  - 源代码行号：在 0、1、2 级优化时，源代码行号会和字节码一起被存储，这样异常就能报告发生的行号；在 3 级及更高优化级别时，行号将不会被存储。

  默认的优化级别通常是0级。
<br><br>

- micropython.`alloc_emergency_exception_buf`(size)

  为紧急异常缓冲区分配 `size` 字节的 RAM（比较合适的大小大约是 100 字节）。当正常的 RAM 分配失败时（比如在中断处理程序中），这个缓冲区就会被用来创建异常，从而在这些情况下提供有用的回溯信息。

  使用这个函数的一个好办法是，把它放在主脚本（如 boot.py 或 main.py）的开头，这样紧急异常缓冲区就会对后续的所有代码都生效。
<br><br>

- micropython.`mem_info`([ verbose ])

  打印当前内存使用信息。如果提供了 `verbose` 参数，则会打印额外信息。

  打印的信息取决于具体实现，目前包括堆栈和堆的使用量。在详细模式下，它会打印整个堆的状态，指示哪些块被使用，哪些是空闲的。
<br><br>

- micropython.`qstr_info`([ verbose ])

  打印当前已驻留字符串的信息。如果提供了 `verbose` 参数，则会打印额外信息。

  所打印的信息取决于具体实现，目前包括已驻留字符串的数量及其占用的 RAM 大小。在详细模式下，它会输出所有驻留在 RAM 中的字符串名称。
<br><br>

- micropython.`stack_use`()

  返回一个整数，表示当前正在使用的堆栈数量。这个值的绝对值并不是特别有用，而是应该用于计算不同点之间的堆栈使用差异。

- micropython.heap_lock()
- micropython.heap_unlock()
- micropython.heap_locked()

  锁定或解锁堆。当锁定时，不能进行内存分配，如果尝试进行堆分配，将引发 `MemoryError`。如果堆当前被锁定，`heap_locked()` 返回真值。

  这些函数可以嵌套使用，即 `heap_lock()` 可以连续调用多次，锁定深度会增加，然后必须调用相同次数的 `heap_unlock()` 才能使堆再次可用。

  `heap_unlock()` 和 `heap_locked()` 都返回一个非负整数代表当前的锁定深度（前者是解锁后的深度），0 表示堆未被锁定。

  如果 REPL 在堆被锁定的情况下变为活动状态，它将被强制解锁。

  **注意**：`heap_locked()` 在大多数版本上默认未启用，需要在编译时设置 `MICROPY_PY_MICROPYTHON_HEAP_LOCKED` 选项。
<br><br>

- micropython.`kbd_intr`(chr)

  设置引发 `KeyboardInterrupt` 异常的字符。默认情况下，在脚本执行期间设置为 3，这对应于 Ctrl-C。向此函数传递 -1 将禁用捕获 Ctrl-C，传递 3 将恢复它。

  在流用于其他目的，此函数可用于防止象 REPL 中输入字符流时捕获 Ctrl-C。
<br><br>

- micropython.`schedule`(func, arg)

  调度函数 `func` "尽快"执行。该函数将传递值 `arg` 作为其单个参数。"尽快"意味着MicroPython 在考虑效率情况下，将尽最大努力在最短的时间内执行该函数，并满足以下条件：
  - 已调度的函数永远不会抢占另一个已调度的函数。
  - 已调度的函数总是在"操作码之间"执行，这意味着所有的基础 Python 操作（如向列表追加元素）均保证是原子性的。
  - 给定的移植版本可能定义"关键区域"，在这些区域内永远不会执行已调度的函数。函数可以在关键区域内调度，但直到退出该区域才会执行。关键区域的一个例子是抢占式中断处理程序（IRQ）。

  此函数的一个用途是从抢占式 IRQ 安排回调。这样的 IRQ 对在 IRQ 中运行的代码施加限制（例如堆可能被锁定），安排稍后调用的函数将解除这些限制。

  在多线程版本上，已调度函数的行为取决于特定移植版本是否启用了全局解释器锁（GIL）：
  - 如果启用了GIL，函数可以抢占任何线程并在其上下文中运行。
  - 如果禁用了GIL，函数将只抢占主线程并在其上下文中运行。

  注意：如果从抢占式 IRQ 调用 `schedule()`，当不允许进行内存分配并且要传递给 `schedule()` 的回调是一个绑定方法时，直接传递会失败。这是因为创建对绑定方法的引用会导致内存分配。解决方案是在类构造函数中创建对方法的引用，并将该引用传递给 `schedule()`。

  有一个有限的队列来保存已调度的函数，如果队列已满，`schedule()` 将引发 `RuntimeError`。
<br><br>

### 类

- class micropython.`RingIO`(size)
- class micropython.`RingIO`(buffer)

  提供一个带流接口的固定字节大小环形缓冲区，可视为类似 `io.BytesIO` 的先进先出队列变体。

  如果通过整数 `size` 参数创建，将分配一个合适的缓冲区。  也可向构造函数传入字节数组 bytearray 或类似的缓冲区协议对象，以实现原地使用。

  使用经典环形缓冲区算法，允许使用任意大小的缓冲区，但会占用一个字节用于跟踪索引。  如果通过整数 `size` 初始化，需注意内部占用：例如 `RingIO(16)` 会在内部分配一个 17 字节的缓冲区，实际可存储 16 字节数据。如果传入预分配的缓冲区，可用存储空间比原长度少 1 字节。例如 `RingIO(bytearray(16))` 仅能存储 15 字节数据。

  当环形缓冲区用于单向数据传输时（如在中断处理程序中写入、在非中断函数中读取，或相反），`RingIO` 实例可保证中断/线程安全。但如果同时在中断和非中断代码中写入同一个实例，可能导致数据损坏。
<br>

  - `any`()

    返回可读取的字符数（整数）。
<br>

  - `read`([ nbytes ])

    读取可用字符（非阻塞）。如果指定 `nbytes`，最多读取 `nbytes` 字节；否则读取尽可能多的数据。
  
    返回值：包含读取字节的 `bytes` 对象。若无可用数据，返回空字节对象。
<br>

  - `readline`([ nbytes ])

    读取一行数据，以换行符结尾（若缓冲区中存在），否则返回缓冲区中的可用字节。如果指定 `nbytes`，最多读取 `nbytes` 字节。

    返回值：包含读取行的 `bytes` 对象。
<br>

  - `readinto`(buf [, nbytes ] )

    将数据读取到提供的 `buf` 中。如果指定 `nbytes`，最多读取 `nbytes` 字节；否则最多读取 `len(buf)` 字节。
  
    返回值：成功读取到 `buf` 中的字节数（整数）。
<br>

  - `write`(buf)
  
    将 `buf` 中的字节非阻塞写入环形缓冲区（受限于缓冲区可用空间）。

    返回值：成功写入的字节数（整数）。
<br>

  - `close`()

    作为标准流接口的一部分，无实际操作，不影响环形缓冲区中的数据。
