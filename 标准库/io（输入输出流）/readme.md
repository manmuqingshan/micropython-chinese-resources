# io（输入/输出流）

io模块包含额外的流类型 (类似文件) 对象和辅助函数。MicroPython在一定程度上做了简化了，以实现更高的效率和节省系统资源。

作为所有具体类行为基础的流类，在 CPython 中遵循少数二分法（成对分类）。在 MicroPython 中，它们被简化并隐式化，以实现更高的效率和节省资源。

CPython 中的一个重要二分法是无缓冲与有缓冲的流。在 MicroPython 中，所有流目前都是无缓冲的。这是因为所有现代操作系统，甚至许多实时操作系统和文件系统驱动程序已经执行缓冲。添加另一个缓冲层会适得其反（这个问题被称为"缓冲膨胀"）,并且会占用宝贵的内存。请注意，仍然有一些情况下缓冲可能是有用的，因此可能会在以后引入可选的缓冲支持。

但在 CPython 中，另一个重要的二分法与"缓冲"相关联 —— 即一个流是否可能发生短读/写操作。短读是指用户从流中请求例如 10 个字节，但得到更少，对于写操作也是如此。在 CPython 中，无缓冲的流自动具有短操作倾向，而缓冲的流则保证避免这些操作。无短读/写是一个重要特性，因为它允许开发更简洁、高效的程序 —— 这对于 MicroPython 来说是非常理想的。因此，尽管 MicroPython 不支持缓冲流，但它仍然提供了无短操作流。是否会有短操作取决于每个特定类的需求，但强烈建议开发者根据上述原因优先考虑无短操作行为。例如，MicroPython 的套接字保证避免短读/写。实际上，到目前为止，核心中还没有短操作流类的示例，这样的类将是一个特定硬件的类，其中这种需求由硬件特性决定。

非短操作行为在非阻塞流的情况下变得复杂，阻塞与非阻塞行为是 CPython 的另一个二分法，MicroPython 同样完全支持。非阻塞流既不等待数据到达也不等待数据写入 —— 它们读取/写入可能的内容，或者发出数据不足（或无法写入数据）的信号。显然，这与"非短操作"策略相冲突。实际上，在 CPython 中非阻塞缓冲（以及这种非短操作）流的情况很复杂 —— 在某些地方，这种组合是禁止的，在某些地方是未定义的或未记录的，在某些情况下会引发冗长的异常。在 MicroPython 中这个问题要简单得多：非阻塞流对于高效的异步操作非常重要，因此这个属性在"非短操作"属性之上。所以，虽然阻塞流会在可能的情况下避免短读/写（唯一可能得到短读的情况是文件末尾或发生错误，但错误不会返回短数据，而是引发异常），非阻塞流可能会产生短数据以避免阻塞操作。

最终的二分法是二进制与文本流。当然，MicroPython 支持这些，但在 CPython 中文本流是固有缓存的，而在 MicroPython 中则不是（实际上，这就是我们可能引入缓存支持的情况之一）。

注意，为了效率，MicroPython 不提供对应于上述层次结构的抽象基类，并且无法在纯 Python 中实现或子类化流类。

## 函数

* io.`open`(name, mode='r', **kwargs)

  打开一个文件，它也是内建函数 `open()` 的别名函数。所有移植版本(用于访问文件系统) 都支持 `mode` 参数，也支持移植版本的特定参数。

## Classes

io中相关的类。


* class io.`StringIO`([string])
* class io.`BytesIO`([string])

  内存文件对象。`StringIO` 用于文本模式 I/O (类似于用 "t" 参数打开文件)，`BytesIO` 用于二进制方式 (类似于用 "b" 参数打开文件)。文件对象的初始内容可以用字符串参数指定（`StringIO` 用普通字符串，`BytesIO`用byets对象）。所有的文件方法，如 read(), write(), seek(), flush(), close() 都可以用在这些对象上，此外还包括下面方法:


    * getvalue()

      获取缓冲区内容。
<br><br>

* class io.`StringIO`(alloc_size)
* class io.`BytesIO`(alloc_size)

  创建一个空的`StringIO`/`BytesIO`对象，该对象已预分配为最多可容纳 alloc_size 字节数。这意味着写入这么多字节不会导致重新分配缓冲区，因此不会出现内存不足或导致内存碎片。这些构造函数是 MicroPython 的扩展，建议仅在特殊情况下和系统级库中使用，不适用于最终用户应用程序。
