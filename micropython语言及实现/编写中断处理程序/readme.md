# 编写中断处理程序

在合适的硬件上，MicroPython 提供了用 Python  编写中断处理程序的能力。中断处理程序 —— 也称为中断服务程序（ISR） —— 被定义为回调函数，它们会响应诸如定时器触发或引脚上的电压变化等事件。这类事件可能在程序代码执行的任何时刻发生，这会带来一系列重要影响，其中一些特定于 MicroPython 语言，另一些则是所有能够响应实时事件的系统所共有的。本文档将首先介绍与该语言相关的特定问题，然后为实时编程新手简要介绍实时编程的相关知识。

本介绍中使用了“缓慢”或“尽可能快”等模糊术语。这是有意为之，因为速度取决于具体应用。中断服务程序（ISR）的可接受持续时间取决于中断发生的频率、主程序的性质以及是否存在其他并发事件。

## 提示与推荐做法

以下是详述的要点，并列出了中断处理程序代码的主要建议：

- 保持代码尽可能简短且简洁。
- 避免内存分配：不要向列表追加元素或向字典插入数据，不要使用浮点数。
- 考虑使用`micropython.schedule`来规避上述限制。
- 当中断服务程序（ISR）返回多个字节时，使用预先分配的`bytearray`。如果要在 ISR 和主程序之间共享多个整数，可考虑使用数组（`array.array`）。
- 当主程序与 ISR 之间共享数据时，考虑在主程序访问数据之前禁用中断，并在访问后立即重新启用（参见“临界区”）。
- 分配一个紧急异常缓冲区（见下文）。

## MicroPython 的相关问题

### 紧急异常缓冲区

如果中断服务程序（ISR）中发生错误，除非专门创建了一个特殊缓冲区，否则 MicroPython 无法生成错误报告。如果在任何使用中断的程序中包含以下代码，调试过程会更简单：

```python
import micropython
micropython.alloc_emergency_exception_buf(100)
```

紧急异常缓冲区只能存储一个异常堆栈跟踪。这意味着，如果在堆被锁定期间处理某个异常时又抛出了第二个异常，即使第二个异常被妥善处理，其堆栈跟踪也会覆盖原始的堆栈跟踪 —— 后续打印缓冲区时，可能会出现令人困惑的异常信息。


### 简洁性

出于多种原因，保持中断服务程序（ISR）代码尽可能简短和简单非常重要。它只应执行事件发生后必须立即完成的操作：可以延迟的操作应交给主程序循环处理。通常，ISR 会处理引发中断的硬件设备，使其为下一次中断做好准备。它会通过更新共享数据来告知主循环中断已发生，然后退出，ISR 应尽快将控制权交回主循环。这并非 MicroPython 特有的问题，下文会更详细地介绍。


### 中断服务程序（ISR）与主程序的通信

通常，ISR 需要与主程序通信。最简单的方式是通过一个或多个共享数据对象，这些对象可以声明为全局变量，或通过类共享（见下文）。这种做法存在多种限制和风险，下文会详细说明。整数、字节、字节数组（bytearray）对象以及数组（来自 array 模块，可存储多种数据类型）通常用于此目的。


### 将对象方法用作回调函数

MicroPython 支持这种强大的技术，它能让中断服务程序（ISR）与底层代码共享实例变量。这也使实现设备驱动程序的类能够能够支持多个设备实例。以下示例使两个 LED 以不同速率闪烁。

```python
import pyb, micropython
micropython.alloc_emergency_exception_buf(100)

class Foo(object):
    def __init__(self, timer, led):
        self.led = led
        timer.callback(self.cb)
    
    def cb(self, tim):
        self.led.toggle()

red = Foo(pyb.Timer(4, freq=1), pyb.LED(1))
green = Foo(pyb.Timer(2, freq=0.8), pyb.LED(2))
```

在这个示例中，`red` 实例将定时器 4 与 LED 1 相关联：当定时器 4 中断发生时，`red.cb()` 被调用，导致 LED 1 改变状态。`green` 实例的工作方式类似：定时器 2 中断会触发 `green.cb()` 执行，并切换 LED 2 的状态。

使用实例方法有两个好处。首先，单个类可以让代码在多个硬件实例之间共享。其次，作为绑定方法，回调函数的第一个参数是 `self`，这使回调能够访问实例数据，并在连续调用之间保存状态。例如，如果上述类在构造函数中设置了变量 `self.count = 0`，那么 `cb()` 可以递增该计数器。这样，`red` 和 `green` 实例就会分别记录各自 LED 状态改变的次数。


### Python 对象的创建

中断服务程序（ISR）不能创建 Python 对象的实例。这是因为 MicroPython 需要从一个称为堆的空闲内存块存储区中为对象分配内存。而中断处理程序中不允许进行堆分配，因为堆分配不具备可重入性。换句话说，中断可能发生在主程序正在执行分配操作的过程中 —— 为了维护堆的完整性，解释器禁止在 ISR 代码中进行内存分配。

由此产生的一个后果是，ISR 不能使用浮点运算，因为浮点数是 Python 对象。同样，ISR 也不能向列表中追加元素。实际上，很难确切判断哪些代码结构会尝试执行内存分配并引发错误消息，这也是保持 ISR 代码简短简洁的另一个原因。

避免此问题的一种方法是让 ISR 使用预先分配的缓冲区。例如，类的构造函数创建一个 bytearray 实例和一个布尔标志。ISR 方法将数据分配到缓冲区的特定位置并设置该标志。内存分配发生在主程序代码中对象实例化时，而不是在 ISR 中。

MicroPython 库的 I/O 方法通常提供使用预先分配缓冲区的选项。例如，pyb.i2c.recv() 可以接受一个可变缓冲区作为其第一个参数，这使其能够在 ISR 中使用。

不使用类或全局变量创建对象的一种方法如下：

```python
def set_volume(t, buf=bytearray(3)):
    buf[0] = 0xa5
    buf[1] = t >> 4
    buf[2] = 0x5a
    return buf
```

当函数首次加载时（通常是在其所在的模块被导入时），编译器会实例化默认的 buf 参数。

当创建绑定方法的引用时，会发生对象实例化。这意味着 ISR 不能将绑定方法传递给函数。一种解决方案是在类的构造函数中创建对绑定方法的引用，并在 ISR 中传递该引用。例如：

```python
class Foo():
    def __init__(self):
        self.bar_ref = self.bar  # 在此处分配操作
        self.x = 0.1
        tim = pyb.Timer(4)
        tim.init(freq=2)
        tim.callback(self.cb)
    
    def bar(self, _):
        self.x *= 1.2
        print(self.x)
    
    def cb(self, t):
        # 传递 self.bar 会导致分配操作
        micropython.schedule(self.bar_ref, 0)
```

其他技巧包括在构造函数中定义和实例化方法，或者传递带有 self 参数的 Foo.bar()。


### Python 对象的使用

由于 Python 的工作方式，对于对象还有一个进一步的限制。当执行 import 语句时，Python 代码会被编译为字节码，通常一行代码会映射为多个字节码。代码运行时，解释器会读取每个字节码并将其作为一系列机器码指令执行。鉴于中断可能发生在机器码指令之间的任何时刻，原始的 Python 代码行可能仅部分执行。因此，主循环中修改的集合、列表或字典等 Python 对象，在中断发生时可能缺乏内部一致性。

一种典型的结果如下：在极少数情况下，ISR 会恰好在对象被部分更新的时刻运行。当 ISR 尝试读取该对象时，就会导致崩溃。由于这类问题通常在罕见的随机情况下发生，因此很难诊断。下文"临界区"部分会介绍规避此问题的方法。

明确什么情况构成对象的修改很重要。修改数组（array）或字节数组（bytearray）的内容是安全的。这是因为字节或字的写入是作为一条不可中断的机器码指令执行的 —— 用实时编程的术语来说，这种写入是原子操作。更新字典项也是如此，因为字典项是机器字，要么是整数，要么是指向对象的指针。用户定义的对象可能会实例化数组或字节数组，主循环和 ISR 都可以修改它们的内容，这是有效的。

当对象的结构被改变时（尤其是字典），就会产生风险。添加或删除键可能会触发重哈希。如果硬中断在重哈希过程中运行并尝试访问某个项，可能会导致崩溃。全局变量在内部是通过字典实现的。因此，主程序应在启动生成硬中断的进程之前创建所有必要的全局变量。应用程序代码也应避免删除全局变量。

MicroPython 支持任意精度的整数。范围在 $ 2^{30}-1 $ 到 $ -2^{30} $ 之间的值会存储在单个机器字中。更大的值则作为 Python 对象存储。因此，对长整数的修改不能视为原子操作。在 ISR 中使用长整数是不安全的，因为当变量值变化时，可能会尝试进行内存分配。


### 克服浮点数限制

通常，最好避免在中断服务程序（ISR）代码中使用浮点数：硬件设备通常处理整数，而浮点数转换通常在主循环中完成。不过，有一些数字信号处理（DSP）算法需要使用浮点数。在具备硬件浮点功能的平台上（如Pyboard），可以使用嵌入式ARM Thumb汇编来规避这一限制。这是因为处理器会将浮点值存储在一个机器字中，因此可以通过浮点数组在ISR和主程序代码之间共享这些值。


### 使用 `micropython.schedule`

这个函数能让中断服务程序（ISR）将一个回调函数安排在"极短时间后"执行。回调函数会进入等待执行的队列，在堆未被锁定时运行。因此，它可以创建 Python 对象并使用浮点数。此外，该回调函数的运行时机还能保证主程序已完成对所有 Python 对象的更新，不会遇到处于部分更新状态的对象。

其典型用法是处理传感器硬件：ISR 从硬件获取数据并使其能够发出进一步的中断，然后安排一个回调函数来处理这些数据。

被安排的回调函数应遵循下文列出的中断处理程序设计原则，以避免因 I/O 操作和共享数据修改（任何抢占主程序循环的代码都可能出现此类问题）而导致的故障。

需要结合中断发生的频率考虑执行时间：如果前一个回调函数正在执行时又发生了中断，新的回调实例会进入队列等待，在前一个实例执行完毕后运行。因此，持续的高频率中断可能导致队列无限制增长，最终引发 `RuntimeError` 错误。

如果要传递给 `schedule()` 的回调函数是绑定方法，请参考“Python 对象的创建”中的说明。


## 异常

如果中断服务程序（ISR）引发异常，该异常不会传到主循环。除非异常被ISR代码处理，否则中断将会被禁用。


## 与 asyncio 的交互

当中断服务程序（ISR）运行时，它可能会抢占 `asyncio` 调度器。如果 ISR 执行了 `asyncio` 操作，调度器的运行可能会受到干扰。无论中断是硬中断还是软中断，也无论 ISR 是否通过 `micropython.schedule` 将执行权传递给了另一个函数，情况都是如此。尤其需要注意的是，在 ISR 上下文中创建或取消任务是无效的。

与 `asyncio` 进行交互的安全方式是，通过 `asyncio.ThreadSafeFlag` 实现带有同步机制的协程。以下代码片段展示了如何响应中断创建任务：

```python
tsf = asyncio.ThreadSafeFlag()

def isr(_):  # 中断处理程序
    tsf.set()

async def foo():
    while True:
        await tsf.wait()
        asyncio.create_task(bar())
```

在这个示例中，ISR 执行与 foo() 执行之间的延迟是不固定的。这是协作式调度固有的特性。最大延迟取决于应用程序和平台，但通常以数十毫秒为单位。



## 通用问题

这仅仅是对实时编程主题的简要介绍。初学者应当注意，实时程序中的设计错误可能会导致一些特别难以诊断的故障。这是因为这些故障可能很少发生，且发生的间隔本质上是随机的。因此，确保初始设计的正确性并在问题出现之前做好预判至关重要。

中断处理程序和主程序的设计都需要考虑到以下问题。

## 中断处理程序设计

如上所述，中断服务程序（ISR）的设计应尽可能简洁。它们必须始终在短暂且可预测的时间内返回。这一点至关重要，因为当 ISR 运行时，主循环会暂停执行 —— 主循环的代码会在随机位置出现停顿。这种停顿可能导致难以诊断的错误，尤其是当停顿时间较长或不固定时。要理解 ISR 运行时间的影响，需要基本掌握中断优先级的概念。

中断按照优先级方案进行组织。ISR 代码可能会被更高优先级的中断打断。如果这两个中断共享数据（见下文“临界区”），会产生相应的问题。此类中断发生时，会给 ISR 代码带来延迟。如果 ISR 运行期间出现较低优先级的中断，该中断会延迟到 ISR 执行完毕后才处理：若延迟过长，低优先级中断可能会失效。ISR 运行缓慢还会导致一种问题：执行期间发生同一类型的第二次中断。第二次中断会在第一次中断结束后处理，但如果输入中断的频率持续超过 ISR 的处理能力，结果会很糟糕。

因此，应避免或尽量减少循环结构。通常应避免对中断源以外的设备进行 I/O 操作：磁盘访问、打印语句、UART 访问等 I/O 操作相对较慢，且持续时间可能不固定。此外，文件系统函数不具备可重入性：在 ISR 和主程序中同时使用文件系统 I/O 会有风险。关键是，ISR 代码不应等待某个事件。如果能保证代码在可预测的时间内返回（例如切换引脚或 LED 状态），则 I/O 操作是可接受的。通过 I2C 或 SPI 访问中断源设备可能是必要的，但需计算或测量此类访问的耗时，并评估其对应用程序的影响。

ISR 与主循环之间通常需要共享数据，可通过全局变量、类变量或实例变量实现。变量类型通常为整数、布尔值，或整数/字节数组（预先分配的整数数组比列表访问速度更快）。当 ISR 修改多个值时，需考虑一种情况：中断发生时，主程序已访问了部分值但未访问全部，这可能导致数据不一致。

考虑以下设计：ISR 将输入数据存储在字节数组中，然后将接收的字节数加到表示待处理总字节数的整数中。主程序读取字节数、处理字节，然后清零待处理字节数。这种设计在一种情况下会失效：主程序刚读取完字节数就发生中断。此时 ISR 将新增数据存入缓冲区并更新接收字节数，但主程序已读取过字节数，只会处理最初接收的数据，新到达的字节会丢失。

有多种方法可避免这种风险，最简单的是使用循环缓冲区。如果无法使用具有固有线程安全性的结构，可采用下文介绍的其他方法。


## 可重入性

如果一个函数或方法在主程序与一个或多个中断服务程序（ISR）之间共享，或者在多个 ISR 之间共享，可能会存在潜在风险。问题在于，该函数本身可能被中断，而该函数的另一个实例会开始运行。若要允许这种情况发生，该函数必须设计为可重入的。如何实现可重入性属于高级主题，超出了本教程的范围。


## 临界区

临界区代码的一个例子是访问多个可能被中断服务程序（ISR）影响的变量的代码段。如果中断恰好发生在访问各个变量的间隙，这些变量的值就会出现不一致。这是一种被称为“竞态条件”的风险场景：ISR 和主程序循环会"竞争"修改变量。为避免不一致，必须采取措施确保在临界区执行期间，ISR 不会修改这些值。实现这一点的一种方法是在临界区开始前调用 `pyb.disable_irq()`，并在结束时调用 `pyb.enable_irq()`。以下是这种方法的示例：

```python
import pyb, micropython, array
micropython.alloc_emergency_exception_buf(100)

class BoundsException(Exception):
    pass

ARRAYSIZE = const(20)
index = 0
data = array.array('i', 0 for x in range(ARRAYSIZE))

def callback1(t):
    global data, index
    for x in range(5):
        data[index] = pyb.rng()  # 模拟输入
        index += 1
        if index >= ARRAYSIZE:
            raise BoundsException('数组越界')

tim4 = pyb.Timer(4, freq=100, callback=callback1)

for loop in range(1000):
    if index > 0:
        irq_state = pyb.disable_irq()  # 临界区开始
        for x in range(index):
            print(data[x])
        index = 0
        pyb.enable_irq(irq_state)  # 临界区结束
    print('循环 {}'.format(loop))
    pyb.delay(1)

tim4.callback(None)
```

临界区也可以包含单行代码和单个变量。考虑以下代码片段：

```python
count = 0

def cb():  # 中断回调函数
    count += 1

def main():
    # 省略设置中断回调的代码
    while True:
        count += 1
```

这个示例展示了一个隐蔽的 bug 来源。主循环中的 `count += 1` 存在一种特定的竞态条件风险，称为“读-改-写”问题。这是实时系统中 bug 的典型成因。在主循环中，MicroPython 会读取 `count` 的值、加 1，然后写回新值。在极少数情况下，中断会在“读”操作之后、“写”操作之前发生。此时中断会修改 `count`，但当 ISR 返回后，主循环的写操作会覆盖这个修改。在实际系统中，这可能导致罕见且难以预测的故障。

如上所述，如果主程序中修改了某个 Python 内置类型的实例，且该实例会被 ISR 访问，就需要格外小心。执行修改操作的代码应被视为临界区，以确保 ISR 运行时该实例处于有效状态。

当不同 ISR 之间共享数据集时，需要特别注意。这里的风险是：低优先级 ISR 部分更新共享数据时，高优先级 ISR 可能会触发。处理这种情况属于高级主题，超出了本介绍的范围，仅需注意下文提到的互斥锁对象有时可以用于此类场景。

在临界区期间禁用中断是最常用且最简单的方法，但这种方法会禁用所有中断，而不仅仅是可能引发问题的那一个。通常不建议长时间禁用中断：对于定时器中断，这会导致回调执行时间变得不确定；对于设备中断，可能导致设备服务不及时，进而引发数据丢失或硬件溢出错误。与 ISR 一样，主程序中的临界区也应具有短暂且可预测的持续时间。

另一种处理临界区的方法可以大幅减少中断被禁用的时间，即使用一种称为“互斥锁”（mutex，名称源于“互斥”的概念）的对象。主程序在进入临界区前锁定互斥锁，结束后解锁。ISR 会检查互斥锁是否处于锁定状态，如果是，则避开临界区并返回。这种设计的挑战在于确定 ISR 无法访问临界变量时应执行的操作。此处提供了一个简单的互斥锁示例(https://github.com/peterhinch/micropython-samples.git)。注意，互斥锁代码确实会禁用中断，但仅持续 8 条机器指令的时间：这种方法的好处是几乎不会影响其他中断。


### 中断与REPL

中断处理程序（例如与定时器相关的处理程序）在程序终止后可能会继续运行，这可能会产生意外结果。例如在 Pyboard 上：

```python
def bar():
    foo = pyb.Timer(2, freq=4, callback=lambda t: print('.', end=''))

bar()
```

这段代码会持续运行，直到定时器被显式禁用或通过 Ctrl+D 重置开发板。

