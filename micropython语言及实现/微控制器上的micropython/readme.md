# 微控制器上的 MicroPython

MicroPython 旨在能够在微控制器上运行。这些微控制器存在一些硬件限制，对于更熟悉传统计算机的程序员来说，这些限制可能并不常见。特别是随机存取存储器（RAM）和非易失性 “磁盘”（闪存）的存储容量有限。本教程提供了充分利用有限资源的方法。由于 MicroPython 运行在基于多种架构的控制器上，因此所介绍的方法是通用的：在某些情况下，需要从特定平台的文档中获取详细信息。

## 闪存 (FLash)

在 Pyboard 上，解决存储容量有限的简单方法是安装一张 SD/TF 卡。但在某些情况下，这种方法并不可行，要么是因为设备没有 SD 卡插槽，要么是出于成本或功耗方面的考虑，因此必须使用片上闪存。包含 MicroPython 子系统的固件存储在板载闪存中，剩余的容量可供用户使用。由于闪存的物理架构原因，这部分容量中可能有一部分无法作为文件系统访问。在这种情况下，可以通过将用户模块整合到固件构建中，然后将固件刷写到设备上，来利用这部分空间。

实现这一目的有两种方式：冻结模块（frozen modules）和冻结字节码（frozen bytecode）。冻结模块将 Python 源代码与固件一起存储；冻结字节码则使用交叉编译器将源代码转换为字节码，再将字节码与固件一起存储。无论采用哪种方式，都可以通过 import 语句来访问模块：

```python
import mymodule
```

生成冻结模块和冻结字节码的步骤因平台而异，关于固件构建的说明可以在源代码树相关部分的 README 文件中找到。

一般来说，步骤如下：

- 克隆 MicroPython [代码仓库](https://github.com/micropython/micropython)。
- 获取（特定于平台的）工具链来构建固件。
- 构建交叉编译器。
- 将需要冻结的模块放在指定目录中（目录取决于模块是要作为源代码还是字节码进行冻结）。
- 构建固件。可能需要使用特定的命令来构建这两种类型的冻结代码 —— 请参考平台文档。
- 将固件写入到设备上。


## 随机存取存储器（RAM）

在减少 RAM 使用量时，需要考虑两个阶段：编译阶段和执行阶段。除了内存消耗外，还存在一个称为堆碎片化的问题。一般来说，最好尽量减少对象的反复创建和销毁，其原因在涉及堆的部分已有介绍。

### 编译阶段

当导入一个模块时，MicroPython 会将代码编译为字节码，然后由 MicroPython 虚拟机（VM）执行。字节码存储在 RAM 中。编译器本身也需要 RAM，但编译完成后，这部分内存就会释放出来供其他使用。

如果已经导入了多个模块，可能会出现 RAM 不足以运行编译器的情况。在这种情况下，import 语句会产生内存异常。

如果一个模块在导入时实例化全局对象，那么在导入时就会消耗 RAM，而这部分 RAM 在后续导入其他模块时，编译器就无法使用了。一般来说，最好避免在导入时运行代码；更好的做法是将初始化代码放在应用程序中，在所有模块都导入后再运行，这样可以最大限度地为编译器提供可用的 RAM。

如果 RAM 仍然不足以编译所有模块，一种解决方法是预编译模块。MicroPython 有一个交叉编译器，能够将 Python 模块编译为字节码（参见 mpy-cross 目录下的 README）。生成的字节码文件扩展名为 .mpy，可以复制到文件系统中，并用常规方式导入。此外，部分或所有模块也可以实现为冻结字节码：在大多数平台上，这能节省更多 RAM，因为字节码直接从闪存运行，而不是存储在 RAM 中。

### 执行阶段

有多种编码技巧可用于减少RAM使用量。

#### 常量

MicroPython提供了`const`关键字，其使用方法如下：

```python
from micropython import const
ROWS = const(33)
_COLS = const(0x10)
a = ROWS
b = _COLS
```

在将常量赋值给变量的两种情况下，编译器会通过替换常量的字面值来避免对常量名称进行查找操作。这节省了字节码，从而节省了 RAM。不过，`ROWS`的值将至少占用两个机器字，一个用于全局字典中的键，另一个用于值。该常量出现在字典中是必要的，因为其他模块可能会导入或使用它。通过在名称前添加下划线（如`_COLS`）可以节省这部分RAM：这种符号在模块外部不可见，因此不会占用 RAM。

`const()`的参数可以是任何在编译时能计算为常量的值，例如 `0x100`、`1 << 8`或`(True, "string", b"bytes")`（详情见下文）。它甚至可以包含其他已定义的`const`符号，例如 `1 << BIT`。


#### 常量数据结构

当存在大量常量数据且平台支持从闪存执行代码时，可通过以下方式节省 RAM：应将这些数据存放在 Python 模块中，并将其冻结为字节码。这些数据必须定义为字节（bytes）对象。编译器"知道"字节对象是不可变的，因此会确保这些对象保留在闪存中，而不是被复制到 RAM 中。`struct` 模块可以帮助在字节类型和其他 Python 内置类型之间进行转换。

在考虑冻结字节码的影响时，需要注意的是，在 Python 中，字符串、浮点数、字节、整数、复数和元组都是不可变的。因此，这些类型会被冻结到闪存中（对于元组，仅当其所有元素都是不可变的时才会被冻结）。例如，在以下代码行中：

```py
mystring = "The quick brown fox"
```

实际的字符串 "The quick brown fox" 将存储在闪存中。在运行时，一个指向该字符串的引用会被赋值给变量 `mystring`，而这个引用仅占用一个机器字。

原则上，长整数也可用于存储常量数据，例如：

```py
bar = 0xDEADBEEF0000DEADBEEF
```

与字符串的例子类似，在运行时，一个指向这个任意大整数的引用会被赋值给变量 `bar`，该引用同样只占用一个机器字。

由常量对象组成的元组本身也是常量。编译器会对这类常量元组进行优化，使其无需在每次使用时都在运行时重新创建。例如：

```py
foo = (1, 2, 3, 4, 5, 6, 100000, ("string", b"bytes", False, True))
```

整个元组会作为一个单独的对象存在（如果代码被冻结，它可能会存储在闪存中），并在每次需要时被引用。


#### 不必要的对象创建

在多种情况下，对象可能会在不经意间被创建和销毁。这会因内存碎片而降低RAM的可用性。以下部分将讨论此类情况。

**字符串拼接**

考虑以下旨在生成常量字符串的代码片段：

```python
var = "foo" + "bar"
var1 = "foo" "bar"
var2 = """\
foo\
bar"""
```

这三段代码产生的结果相同，但第一段会在运行时不必要地创建两个字符串对象，在生成第三个字符串之前，还会为拼接操作分配更多的RAM。而其他两段代码会在编译时完成拼接，效率更高，还能减少内存碎片。

当字符串必须动态创建后再传入文件等流时，如果采用分段处理的方式，将节省RAM。不要创建一个大的字符串对象，而是创建子字符串，将其传入流中后，再处理下一个子字符串。

创建动态字符串的最佳方式是使用字符串的`format()`方法：

```python
var = "Temperature {:5.2f} Pressure {:06d}\n".format(temp, press)
```

**缓冲区**

在访问 UART、I2C 和 SPI 接口等设备时，使用预先分配的缓冲区可以避免创建不必要的对象。考虑以下两个循环：

```python
while True:
    var = spi.read(100)
    # 处理数据

buf = bytearray(100)
while True:
    spi.readinto(buf)
    # 处理buf中的数据
```

第一个循环在每次迭代时都会创建一个缓冲区，而第二个循环则重用预先分配的缓冲区；这不仅速度更快，在内存碎片方面也更高效。

**字节比整数占用空间更小**

在大多数平台上，一个整数会占用4个字节。考虑对函数 `foo()` 的三次调用：

```python
def foo(bar):
    for x in bar:
        print(x)

foo([1, 2, 0xff])
foo((1, 2, 0xff))
foo(b'\1\2\xff')
```

第一次调用时，每次执行代码都会在 RAM 中创建一个整数列表。第二次调用会在编译阶段创建一个常量元组对象（仅包含常量对象的元组），因此它只会被创建一次，比列表更高效。第三次调用则高效地创建了一个字节对象，占用的 RAM 空间最少。

如果该模块被冻结为字节码，那么这个元组和字节对象都会存储在闪存中。

**字符串与字节**

Python3 引入了 Unicode 支持，这使得字符串和字节数组之间产生了区别。只要字符串中的所有字符都是 ASCII 码（即值小于 126），MicroPython 就确保 Unicode 字符串不会占用额外空间。如果需要全 8 位范围内的值，可以使用字节（bytes）和字节数组（bytearray）对象，以确保不会占用额外空间。注意，大多数字符串方法（例如 `str.strip()`）也适用于字节实例，因此去除 Unicode 的过程可以很轻松。

```python
s = 'the quick brown fox'   # 一个字符串实例
b = b'the quick brown fox'  # 一个字节实例
```

当需要在字符串和字节之间进行转换时，可以使用`str.encode()`和`bytes.decode()`方法。注意，字符串和字节都是不可变的。任何以这类对象为输入并生成另一个对象的操作，都意味着至少需要分配一次 RAM 来生成结果。在下面的第二行代码中，会分配一个新的字节对象。如果 `foo` 是一个字符串，也会发生同样的情况。

```python
foo = b' empty whitespace'
foo = foo.lstrip()
```

**运行时编译器执行**

Python 的`eval`和`exec`函数会在运行时调用编译器，这需要大量的 RAM。需要注意的是，`micropython-lib` 中的 `pickle` 库会用到`exec`。在对象序列化方面，使用 `json` 库可能在 RAM 使用上更高效。

**在闪存中存储字符串**

Python 字符串是不可变的，因此有可能存储在只读内存中。编译器可以将 Python 代码中定义的字符串存放在闪存里。与冻结模块一样，需要在电脑上有源代码树的副本以及用于构建固件的工具链。只要模块可以被导入并运行，即使尚未完全调试好，该流程也能正常工作。

导入模块后，执行以下命令：
```python
micropython.qstr_info(1)
```

然后将所有`Q(xxx)`行复制粘贴到文本编辑器中。检查并移除明显无效的行。打开`qstrdefsport.h`文件（该文件可在`ports/stm32`目录或所用架构对应的等效目录中找到）。将修正后的行复制粘贴到文件末尾。保存文件，重新构建并刷写固件。可以通过再次导入模块并执行以下命令来检查结果：

```python
micropython.qstr_info(1)
```

此时`Q(xxx)`行应该已经消失了。


## 堆（heap）

当运行中的程序实例化一个对象时，所需的 RAM 会从一个固定大小的内存池（称为堆）中分配。当对象超出作用域（即代码无法再访问该对象）时，这个冗余对象就被称为"垃圾"。一个被称为"垃圾回收"（GC）的过程会回收这些内存，将其归还给堆。这个过程会自动运行，但也可以通过调用`gc.collect()`直接触发。

关于这一点的讨论较为复杂。如果想"快速解决"相关问题，可以定期执行以下操作：

```python
gc.collect()
gc.threshold(gc.mem_free() // 4 + gc.mem_alloc())
```

### 内存碎片

假设程序先创建一个对象`foo`，然后创建一个对象`bar`。随后`foo`超出作用域，但`bar`仍然存在。`foo`所使用的 RAM 会被 GC 回收。然而，如果`bar`被分配到了更高的地址，那么从`foo`回收的 RA M将只能用于存储不大于`foo`的对象。在复杂或长时间运行的程序中，堆可能会变得碎片化：尽管有大量 RAM 可用，但没有足够的连续空间来分配某个特定对象，程序会因内存错误而失败。

上面概述的技巧旨在最大限度地减少这种情况。当需要大型永久性缓冲区或其他对象时，最好在程序执行初期、内存碎片产生之前就实例化它们。通过监控堆的状态和控制GC，还可以进一步改进（这些将在下文概述）。

### 报告功能

有多个库函数可用于报告内存分配情况和控制垃圾回收（GC）。这些函数可在`gc`和`micropython`模块中找到。以下示例可粘贴到 REPL 中（按`ctrl+e`进入粘贴模式，按`ctrl+d`运行）。

```python
import gc
import micropython

gc.collect()
micropython.mem_info()
print('-----------------------------')
print('初始空闲内存: {} 已分配内存: {}'.format(gc.mem_free(), gc.mem_alloc()))

def func():
    a = bytearray(10000)

gc.collect()
print('函数定义后: {} 已分配内存: {}'.format(gc.mem_free(), gc.mem_alloc()))

func()
print('函数运行后空闲内存: {} 已分配内存: {}'.format(gc.mem_free(), gc.mem_alloc()))

gc.collect()
print('垃圾回收后空闲内存: {} 已分配内存: {}'.format(gc.mem_free(), gc.mem_alloc()))
print('-----------------------------')

micropython.mem_info(1)
```

上面使用的方法：
- `gc.collect()`：强制进行垃圾回收（参见脚注）。
- `micropython.mem_info()`：打印 RAM 使用情况摘要。
- `gc.mem_free()`：返回空闲堆大小（以字节为单位）。
- `gc.mem_alloc()`：返回当前已分配的字节数。
- `micropython.mem_info(1)`：打印堆使用情况表（详情见下文）。

生成的数值取决于具体平台，但可以看出，声明函数会使用少量 RAM（以编译器生成的字节码形式存在，编译器使用的 RAM 已被回收）。运行函数会使用超过 10KiB 的内存，但返回时，`a`因超出作用域且无法被引用而成为垃圾。最后的`gc.collect()`会回收该内存。


`micropython.mem_info(1)`生成的最终输出细节会有所不同，但可按如下方式解读：

| 符号 | 含义 |
|:----:|------|
| . | 空闲块 |
| h | 头部块 |
| = | 尾部块 |
| m | 已标记的头部块 |
| T | 元组 |
| L | 列表 |
| D | 字典 |
| F | 浮点数 |
| B | 字节码 |
| M | 模块 |
| S | 字符串或字节 |
| A | 字节数组 |


每个字母代表一个内存块，每个块为 16 字节。因此，堆转储的每一行代表 0x400 字节（即1KiB）的 RAM。


### 垃圾回收的控制

通过调用`gc.collect()`，可以在任何时候触发垃圾回收（GC）。定期执行此操作是有益的，一来可以预先防止内存碎片，二来有助于提升性能。一次垃圾回收可能需要几毫秒，但当需要回收的内容较少时会更快（在 Pyboard 上约为1毫秒）。显式调用该函数可以将延迟降至最低，同时确保它在程序中可接受的节点执行。

自动垃圾回收会在以下情况下触发：
- 当内存分配尝试失败时，会执行一次垃圾回收，然后重新尝试分配。只有当再次失败时，才会抛出异常。
- 当空闲 RAM 量低于某个阈值时，会触发自动垃圾回收。这个阈值可以随着程序的执行过程进行调整：
  ```python
  gc.collect()
  gc.threshold(gc.mem_free() // 4 + gc.mem_alloc())
  ```
  这样设置后，当空闲堆中超过 25% 的空间被占用时，就会触发垃圾回收。

一般来说，模块应在运行时通过构造函数或其他初始化函数来实例化数据对象。原因是，如果在初始化阶段就实例化数据，那么在后续导入其他模块时，编译器可能会面临 RAM 不足的问题。如果模块确实需要在导入时实例化数据，那么在导入后调用`gc.collect()`可以缓解这一问题。


## 字符串操作

MicroPython 以高效的方式处理字符串，理解这一点有助于设计在微控制器上运行的应用程序。当模块被编译时，多次出现的字符串只会被存储一次，这一过程称为字符串驻留。在 MicroPython 中，驻留的字符串被称为 `qstr`（准字符串）。在正常导入的模块中，这个单一实例会位于 RAM 中，但如前所述，在被冻结为字节码的模块中，它会位于闪存中。

字符串比较也是通过哈希而非逐字符的方式高效进行的。因此，使用字符串而非整数在性能和 RAM 占用方面的代价可能都很小 —— 这一点可能会让 C 语言程序员感到惊讶。


## 后记

MicroPython 通过引用传递、返回对象，并且（默认情况下）通过引用复制对象。一个引用仅占用一个机器字，因此这些操作在 RAM 使用和速度方面都具有高效性。

当需要使用大小既不是一个字节也不是一个机器字的变量时，有一些标准库可帮助高效存储这些变量并执行转换操作。请参见`array`、`struct`和`uctypes`模块。

注：gc.collect()的返回值

在 Unix 和 Windows 平台上，`gc.collect()`方法会返回一个整数，该整数表示在此次回收中被释放的不同内存区域的数量（更准确地说，是被转为空闲状态的头部块的数量）。出于效率考虑，裸机版本不会返回此数值。
