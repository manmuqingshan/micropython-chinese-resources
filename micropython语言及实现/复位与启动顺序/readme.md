# 复位与启动顺序

运行 MicroPython 的设备在复位后会遵循特定的启动顺序进行启动和初始化。

## 硬复位

硬复位启动发生在开发板首次上电时，即冷启动。这是对微控制器（MCU）硬件的完全复位。

MicroPython 会初始化所有必要的硬件（包括嵌入式时钟、电源调节器、内部串行UART等），然后启动 MicroPython 环境。硬复位后，现有的实时时钟（RTC）配置可能会保留，但所有其他硬件状态都会被清除。

以下多种事件都可能触发相同的硬复位：

- Python代码执行 `machine.reset()`。
- 用户按下开发板上的物理复位按钮（如果有）。
- 从深度睡眠中唤醒（在大多数移植版上）。
- MCU 硬件看门狗复位。
- MCU 硬件欠压检测器触发。

特定硬件复位触发的详细信息取决于移植版及相关硬件。`machine.reset_cause()`函数可用于进一步确定复位的原因。

## 软复位

当 MicroPython 已在运行时，可通过在 EPL中 输入 Ctrl+D 执行 `machine.soft_reset()` 触发软复位。

软复位会清除 Python 解释器，释放所有 Python 内存，并重新启动 MicroPython 环境。

软复位会清除的状态包括：
- 所有 Python 变量、对象、导入的模块等。
- 大多数通过 `machine` 模块配置的外设。仅有极少数例外，例如在大多数移植版上，`machine.Pin` 的模式（即引脚是输入还是输出、高电平还是低电平）不会被复位。而更高级的配置（如`Pin.irq()`）则总会被复位。
- 蓝牙。
- 网络套接字。打开的 TCP 套接字会向通信对方正常关闭。
- 打开的文件。文件系统会保持在有效状态。

软复位后仍保持不变的系统状态包括：
- 任何现有的网络连接（以太网、Wi-Fi 等）在 IP 网络层仍保持活跃。从代码中查询网络接口可能会显示网络接口仍处于活跃状态，并配置有 IP 地址等。
- 活跃的 REPL 在软复位前后看起来是连续的，除了一些特殊情况：
  - 如果使用`machine.USBDevice`类创建了自定义 USB 接口，那么内置 USB 串行设备可能会出现断开并重新连接的情况，因为复位期间必须清除自定义 USB 接口。
  - 串行 UART REPL 会恢复其默认硬件配置（如波特率等）。
- 软复位通常不会改变 CPU 时钟速度。
- RTC 配置（即当前时间的设置）不会被软复位改变。

## 启动顺序

无论是硬复位还是软复位，MicroPython 启动时都会按以下顺序执行启动序列：

### `_boot.py`

这是一个冻结在 MicroPython 固件中的内部脚本。MicroPython 在许多移植版中都提供该脚本，用于执行必要的初始化操作。

例如，`_boot.py`会检测新设备的首次启动，并格式化内部闪存文件系统以备用。

除非要创建自定义的 MicroPython 构建版本或添加新硬件，否则可能无需关注`_boot.py`。除非确实清楚自己在做什么，否则最好不要修改其内容。

### `boot.py`

可以使用 `mpremote` 将名为 `boot.py` 的文件复制到开发板的内部文件系统中。

如果存在 `boot.py` 文件，则会执行该文件。可以在 `boot.py` 中添加代码以执行自定义的一次性初始化操作（例如配置开发板的硬件）。

一种常见做法是在 `boot.py` 中配置开发板的网络连接，以便复位后该连接始终可用，供 REPL、`mpremote` 等使用。

⚠️ 警告
- `boot.py` 应始终能退出，而不是无限运行。
- 某些硬件初始化会延迟到 `boot.py` 退出后才执行。这包括 stm32 上的 USB 初始化，以及所有支持 `machine.USBDevice` 的版本。在这些移植版上，`boot.py` 打印的输出可能要等到 `boot.py` 运行完毕后，才能在内置 USB 串行端口上看到。这种延迟初始化的目的是，能够在 `boot.py` 中预先配置特定硬件，然后让硬件以正确的配置启动。

💡 注意
- 有时不使用 `boot.py` 文件，而将所有初始化代码放在 `main.py` 的开头会更简单。

### `main.py`

与 `boot.py` 类似，可以将名为 `main.py` 的文件复制到开发板的内部文件系统中。如果存在该文件，启动过程接下来会执行它。

`main.py` 用于存放设备每次启动时运行的 Python 代码。

关于`main.py`使用的一些提示：
- `main.py`不必退出，可以在其中放入无限的 `while True` 循环。
- 对于复杂的 Python 应用，无需将所有代码都放在 `main.py` 中。`main.py` 可以是一个简单的入口点，用于导入应用程序并启动执行：
  ```python
  import my_app
  my_app.main()
  ```
  这有助于保持应用程序结构清晰，还能轻松地在开发板上安装多个应用程序并在它们之间切换。
- 编写健壮的应用程序时，一个好的做法是在 `main.py` 中用异常处理器包裹代码，以便在代码崩溃时采取适当的措施。例如：
  ```python
  import machine, sys
  import my_app
  
  try:
      my_app.main()
  except Exception as e:
      print("main中发生致命错误：")
      sys.print_exception(e)
      
  # 若发生普通 Exception 或 main() 退出，复位开发板。
  # 若发生非 Exception 错误（如KeyboardInterrupt（Ctrl+C）），
  # 这段代码会进入REPL。若要始终复位，可将 machine.reset() 放在 finally 块中。
  machine.reset()
  ```
  否则，在发生任何崩溃或`main`退出时，MicroPython 都会进入 REPL（见下文）。
- 在`boot.py`中设置的任何全局变量，在`main.py`的全局上下文中仍会保持设置状态。
- 为了充分优化闪存使用和内存消耗，可以将预编译的 `main.mpy` 和/或 `boot.mpy` 文件复制到文件系统，甚至将它们冻结到固件构建中。
- 当从原始 REPL 模式发起软复位时（例如，当`mpremote`或其他程序直接与 MicroPython 交互时），`main.py` 的执行会被跳过。

### 交互式解释器（REPL）

如果未找到`main.py`，或者`main.py`执行退出，那么 MicrpPython 交互式解释器模式（又名REPL）会立即启动。

💡 注意
- 即便 `main.py` 包含无限循环，在 REPL 串行端口上输入 Ctrl+C 也会触发 `KeyboardInterrupt`。如果没有异常处理器捕获该异常，`main.py` 会退出并启动 REPL。

在 `boot.py` 和 `main.py` 中设置的所有全局变量，在REPL的全局上下文中仍会保持设置状态。

REPL 会持续运行，直到 Python 代码触发硬复位或软复位为止。


## 变砖（启动失败）

虽然很少见，但MicroPython有可能在启动过程中变得无响应，这种状态有时被称为“变砖”。

例如：
- 如果`boot.py`执行卡住，且原生 USB 串行端口始终未初始化。
- 如果 Python 代码重新配置了 REPL 接口，导致其无法访问。

但是请放心，这种情况是可以恢复的！

### 键盘中断（KeyboardInterrupt）

在很多情况下，打开 REPL 串行端口并输入 Ctrl+C 会触发 `KeyboardInterrupt`，可能会导致正在运行的脚本退出并启动 REPL。在 REPL 中，你可以使用 `os.remove()` 删除有问题的 Python 文件：

```python
import os
os.remove('main.py')
```

要确认内部文件系统中仍存在哪些文件，可以执行：

```python
import os
os.listdir()
```

### 安全模式和恢复出厂设置

如果无法顺利访问REPL，可能需要执行以下两种操作之一：
1. “安全模式”启动，这种模式会跳过 `boot.py` 和 `main.py`，并立即启动 REPL，以便进行清理。此功能仅在部分版本上支持。
2. 恢复出厂设置，以擦除闪存文件系统的全部内容。如果内部闪存文件系统因某种原因损坏，这可能也是必要的操作。

不同硬件的具体操作流程不同，请参考相应的说明。对于未具体说明的硬件，恢复出厂设置的流程包括擦除开发板的整个闪存，然后重新从头刷写 MicroPython 固件。通常这需要使用最初安装 MicroPython 时所用的工具。请参考开发板的文档，如果你不确定，也可以在 GitHub 讨论区咨询。

⚠️ 警告
如果在重新刷写 MicroPython 固件之前没有先擦除整个闪存，通常无法从变砖状态恢复，因为固件更新通常会保留文件系统的内容。
