# 最大化 MicroPython 速度

本教程介绍提高 MicroPython 代码性能的方法。涉及其他语言的优化将在其他地方介绍，即使用 C 语言编写的模块和 MicroPython 内联汇编器。

开发高性能代码的过程包括以下阶段，应按所列顺序执行：

- 为速度而设计。
- 编写代码并调试。

优化步骤：

- 找出代码中最慢的部分。
- 提高 Python 代码的效率。
- 使用原生代码生成器。
- 使用 viper 代码生成器。
- 使用硬件特定的优化。


## 为速度而设计

性能问题应从一开始就加以考虑。这包括确定代码中哪些部分对性能最为关键，并对其设计给予特别关注。优化过程应在代码经过测试之后进行：如果初始设计是正确的，那么优化将变得简单，甚至可能根本没有必要。


### 算法

为实现高性能而设计任何程序时，最重要的一点是确保采用了最佳算法。这更多是教科书涵盖的内容，而非本 MicroPython 指南的重点，但采用那些以高效著称的算法，有时能带来显著的性能提升。


### 内存分配

要设计高效的 MicroPython 代码，必须了解解释器分配内存（RAM）的方式。当创建一个对象或对象大小增加时（例如向列表中追加元素），所需的内存会从一个称为“堆”的内存块中分配。这一过程会耗费大量时间；此外，它有时还会触发一个称为"垃圾回收"的过程，该过程可能需要数毫秒。

因此，如果一个对象只创建一次且不允许其大小增长，那么函数或方法的性能就可以得到提升。这意味着该对象在其使用期间会一直存在：通常情况下，它会在类的构造函数中实例化，并在各种方法中使用。

这一点将在下文"控制垃圾回收"部分进行更详细的阐述。


### 缓冲区

上述情况的一个例子是常见的需要缓冲区的场景，例如用于与设备通信的缓冲区。一个典型的驱动程序会在构造函数中创建缓冲区，并在其输入/输出方法中使用该缓冲区，而这些方法会被反复调用。

MicroPython 库通常支持预分配缓冲区。例如，支持流接口的对象（如文件或 UART）提供了`read()`方法（该方法会为读取的数据分配新的缓冲区），但也提供了`readinto()`方法，用于将数据读入已有的缓冲区。

一些可用于创建可重复使用的缓冲区对象的实用类：
- `bytearray`
- `array`
- `io.StringIO`和`io.BytesIO`
- `micropython.RingIO`


### 浮点数

一些 MicroPython 移植版本会在堆上分配浮点数。另一些移植版本可能缺乏专用的浮点协处理器，只能通过"软件"方式执行浮点算术运算，其速度远低于整数运算。

在性能至关重要的场景中，应使用整数运算，仅在对性能要求不高的代码部分限制使用浮点数。例如，可以先快速将 ADC 读数以整数形式捕获到数组中，之后再将其转换为浮点数进行信号处理。


### 数组

可以考虑使用各种类型的数组类来替代列表。`array`模块支持多种元素类型，其中 8 位元素由 Python 内置的`bytes`和`bytearray`类支持。这些数据结构都将元素存储在连续的内存位置中。同样，为了避免在关键代码中进行内存分配，应预先分配这些数据结构，并将其作为参数或绑定对象传递。

### 内存视图（Memoryviews）

当传递`bytearray`等对象的切片时，Python 会创建一个副本，这需要分配与切片大小成比例的内存。使用`memoryview`对象可以缓解这一问题。`memoryview`本身在堆上分配，但它是一个小型的固定大小对象，与它所指向的切片大小无关。对`memoryview`进行切片会创建一个新的`memoryview`，因此这不能在中断服务程序中执行。此外，切片语法`a:b`会通过实例化`slice(a, b)`对象导致进一步的内存分配。

```python
ba = bytearray(10000)  # 大数组
func(ba[30:2000])      # 传递副本，约分配2K新内存
mv = memoryview(ba)    # 分配小型对象
func(mv[30:2000])      # 传递内存指针
```

`memoryview`只能应用于支持缓冲区协议的对象，包括数组，但不包括列表。需要注意的一点是，当`memoryview`对象存在时，它会使原始缓冲区对象保持活跃状态。因此，`memoryview`并非万能良药。例如，在上面的示例中，如果你已经处理完10K的缓冲区，只需要其中30:2000的字节，那么最好创建一个切片，让10K的缓冲区被回收（准备好进行垃圾回收），而不是创建一个长期存在的`memoryview`并占用10K的内存阻碍垃圾回收。

尽管如此，`memoryview`在高级预分配缓冲区管理中仍然不可或缺。前面讨论的`readinto()`方法会将数据放在缓冲区的开头并填满整个缓冲区。如果需要将数据放入现有缓冲区的中间位置怎么办？只需创建一个指向缓冲区所需部分的`memoryview`，并将其传递给`readinto()`即可。


### 字符串与字节

MicroPython 采用字符串驻留机制，当存在多个相同字符串时可节省空间。每次在运行时分配新字符串（例如，将另外两个字符串拼接时），MicroPython 都会检查该新字符串是否可以驻留，以节省 RAM。

如果代码中包含对性能要求严格的字符串操作，那么可以考虑使用字节对象和字节字面量（即b"abc"）。这会跳过驻留检查，并且比使用字符串对象执行相同操作快好几倍。

**注意**: 要想获得最快的性能，始终要完全避免创建新对象，例如使用前面所述的可重复使用的缓冲区。


## 找出代码中最慢的部分

这一过程被称为性能分析，在教科书中有相关介绍，并且（对于标准Python而言）有各种软件工具支持。对于可能在 MicroPython 平台上运行的小型嵌入式应用程序，通常可以通过明智地使用`time`模块中记录的`ticks`函数组来确定最慢的函数或方法。代码执行时间可以用毫秒（ms）、微秒（us）或CPU周期为单位进行测量。

通过添加`@timed_function`装饰器，可以对任何函数或方法进行计时，如下所示：

```python
def timed_function(f, *args, **kwargs):
    myname = str(f).split(' ')[1]
    def new_func(*args, **kwargs):
        t = time.ticks_us()
        result = f(*args, **kwargs)
        delta = time.ticks_diff(time.ticks_us(), t)
        print('Function {} Time = {:6.3f}ms'.format(myname, delta/1000))
        return result
    return new_func
```


## MicroPython代码改进

### const()声明

MicroPython 提供了`const()`声明。它的工作方式类似于C语言中的`#define`，当代码被编译为字节码时，编译器会用数值替换标识符。这避免了在运行时进行字典查找。`const()`的参数可以是任何在编译时能求值为整数的内容，例如`0x100`或`1 << 8`。

### 缓存对象引用

当函数或方法需要反复访问对象时，将对象缓存到局部变量中可以提高性能：

```python
class foo(object):
    def __init__(self):
        self.ba = bytearray(100)
    def bar(self, obj_display):
        ba_ref = self.ba
        fb = obj_display.framebuffer
        # 使用这两个对象的迭代代码
```

这样就避免了在`bar()`方法体内反复查找`self.ba`和`obj_display.framebuffer`。


### 控制垃圾回收

当需要进行内存分配时，MicroPython 会尝试在堆上找到一个大小合适的块。这可能会失败，通常是因为堆中充斥着代码不再引用的对象。如果分配失败，名为"垃圾回收"的过程会回收这些冗余对象所使用的内存，然后再次尝试分配 —— 这个过程可能需要几毫秒。

通过定期调用`gc.collect()`来主动触发垃圾回收可能会带来一些好处。首先，在实际需要之前进行回收会更快 —— 如果频繁执行，通常耗时在1毫秒左右。其次，你可以控制代码中消耗这段时间的位置，而不是让更长的延迟随机发生（可能发生在对速度要求严格的部分）。最后，定期执行回收可以减少堆的碎片化。严重的碎片化可能导致无法恢复的分配失败。


## 原生代码生成器

这会使 MicroPython 编译器生成原生 CPU 操作码，而非字节码。它涵盖了 MicroPython 的大部分功能，因此大多数函数无需修改（但请参见下文）。可通过函数装饰器调用它：

```python
@micropython.native
def foo(self, arg):
    buf = self.linebuf  # 缓存的对象
    # 代码
```

原生代码生成器的当前实现存在某些限制：

- 不支持上下文管理器（`with`语句）。
- 不支持生成器。
- 如果使用`raise`，必须提供参数。

性能提升（大约比字节码快一倍）的代价是编译后的代码体积增大。


## Viper代码生成器

上面讨论的优化都涉及符合标准的 Python 代码。而 Viper 代码生成器并不完全符合标准，它支持特殊的 Viper 原生数据类型以追求更高性能。整数处理不符合标准，因为它使用机器字：在32位硬件上，算术运算以 2**32 为模进行。

与原生代码生成器一样，Viper 也会生成机器指令，但它还会执行进一步的优化，显著提升性能，尤其是在整数运算和位操作方面。通过装饰器调用它：

```python
@micropython.viper
def foo(self, arg: int) -> int:
    # 代码
```

如上面的代码片段所示，使用 Python 类型提示来辅助 Viper 优化器是很有好处的。类型提示提供了参数和返回值的数据类型信息，这些是 Python 语言的标准特性，在 [PEP0484](https://www.python.org/dev/peps/pep-0484/) 中有正式定义。Viper 支持它自己的一组类型，即 `int`、`uint`（无符号整数）、`ptr`、`ptr8`、`ptr16`和`ptr32`。`ptrX`类型将在下面讨论，目前，`uint`类型只有一个用途：作为函数返回值的类型提示。如果这样的函数返回`0xffffffff`，Python 会将结果解释为 2**32-1，而不是-1。

除了原生代码生成器所施加的限制外，还存在以下约束：

- 不允许使用默认参数值。
- 可以使用浮点数，但不会对其进行优化。

Viper 提供了指针类型来辅助优化器，包括：

- `ptr`：指向对象的指针。
- `ptr8`：指向一个字节。
- `ptr16`：指向一个16位半字。
- `ptr32`：指向一个32位机器字。

指针的概念对 Python 程序员来说可能不太熟悉。它与 Python 的 `memoryview` 对象有相似之处，因为它提供了对内存中存储数据的直接访问。可以使用下标符号访问元素，但不支持切片：一个指针只能返回单个元素。它的目的是提供对连续内存位置中存储的数据的快速随机访问，例如存储在支持缓冲区协议的对象中的数据，以及微控制器中内存映射的外设寄存器。需要注意的是，使用指针编程存在风险：不会进行边界检查，编译器也不会阻止缓冲区溢出错误。

典型用法是缓存变量：

```python
@micropython.viper
def foo(self, arg: int) -> int:
    buf = ptr8(self.linebuf)  # self.linebuf是bytearray或bytes对象
    for x in range(20, 30):
        bar = buf[x]  # 通过指针访问数据项
        # 省略的代码
```

在这种情况下，编译器"知道"`buf`是字节数组的地址，它可以生成代码在运行时快速计算`buf[x]`的地址。当使用强制类型转换将对象转换为 Viper 原生类型时，应该在函数开始时执行，而不是在关键的计时循环中，因为强制类型转换操作可能需要几微秒。强制类型转换的规则如下：

- 当前的强制类型转换运算符有：`int`、`bool`、`uint`、`ptr`、`ptr8`、`ptr16`和`ptr32`。
- 强制类型转换的结果将是一个原生的 Viper 变量。
- 强制类型转换的参数可以是 Python 对象或原生的 Viper 变量。
- 如果参数是原生的 Viper 变量，那么强制类型转换是无操作（即运行时没有开销），只是改变类型（例如从`uint`到`ptr8`），以便可以使用该指针进行存储/加载操作。
- 如果参数是 Python 对象，且强制类型转换为`int`或`uint`，那么该 Python 对象必须是整数类型，并返回该整数对象的值。
- bool 强制类型转换的参数必须是整数类型（布尔值或整数）；当用作返回类型时，Viper 函数将返回 True 或 False 对象。
- 如果参数是 Python 对象，且强制类型转换为`ptr`、`ptr8`、`ptr16`或`ptr32`，那么该 Python 对象必须要么支持缓冲区协议（在这种情况下，返回指向缓冲区开始处的指针），要么必须是整数类型（在这种情况下，返回该整数对象的值）。

往只读对象的指针写入数据将导致未定义的行为。

下面的示例说明了如何使用`ptr16`强制类型转换来切换X1引脚n次：

```python
BIT0 = const(1)
@micropython.viper
def toggle_n(n: int):
    odr = ptr16(stm.GPIOA + stm.GPIO_ODR)
    for _ in range(n):
        odr[0] ^= BIT0
```

关于这三种代码生成器的详细技术描述，可以在Kickstarter上的这里（[注1](https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832)）和这里（[注2](https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145)）找到。


## 直接访问硬件

**注意**：本节中的代码示例是针对 Pyboard 的，不过所描述的技术也可应用于其他 MicroPython 移植版本。

这属于更高级的编程范畴，需要具备一些目标微控制器（MCU）的相关知识。以在 Pyboard 上切换输出引脚状态为例，标准的做法是编写：

```python
mypin.value(mypin.value() ^ 1)  # mypin已实例化为输出引脚
```

这涉及到两次调用`Pin`实例的`value()`方法所带来的开销。通过对芯片GPIO端口输出数据寄存器（odr）的相关位执行读/写操作，可以消除这种开销。为方便实现，`stm` 模块提供了一组常量，这些常量给出了相关寄存器的地址。对P4引脚（CPU的A14引脚，对应绿色LED）进行快速切换的操作可按如下方式执行：

```python
import stm
import machine

BIT14 = const(1 << 14)
machine.mem16[stm.GPIOA + stm.GPIO_ODR] ^= BIT14
```
