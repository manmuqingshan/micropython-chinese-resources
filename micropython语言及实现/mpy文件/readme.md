# MicroPython 的 .mpy 文件

MicroPython 定义了 `.mpy` 文件的概念，这是一种二进制容器文件格式，用于存储预编译代码，并且可以像普通的 `.py` 模块一样被导入。只要导入机制能以常规方式找到 `foo.mpy`，就可以通过 `import foo` 导入该文件。通常，会按顺序搜索 `sys.path` 中列出的每个目录。在搜索特定目录时，会先查找 `foo.py`，如果未找到，则查找 `foo.mpy`，如果两者都未找到，则继续搜索下一个目录。因此，`foo.py` 的优先级高于 `foo.mpy`。

这些 `.mpy` 文件可以包含字节码，这些字节码通常是通过 `mpy-cross` 程序从 Python 源文件（`.py` 文件）生成的。对于某些架构，`.mpy` 文件还可以包含原生机器码，其生成方式多种多样，最常见的是从 C 源代码生成。


## .mpy 文件的版本控制和兼容性

一个 `.mpy` 文件可能与某个 MicroPython 系统兼容，也可能不兼容。兼容性基于以下几点：

- `.mpy` 文件的版本：文件版本必须与加载它的系统所支持的版本匹配。
- `.mpy` 文件的子版本：如果 `.mpy` 文件包含原生机器码，则文件的子版本必须与加载它的系统所支持的版本匹配。否则，如果 `.mpy` 文件中没有原生机器码，那么加载时会忽略子版本。
- 小整数位数：`.mpy` 文件需要小整数具有最小位数，加载它的系统必须至少支持这么多位。
- 原生架构：如果 `.mpy` 文件包含原生机器码，它会指定该机器码的架构，加载它的系统必须支持该架构代码的执行。

如果 MicroPython 系统支持导入 `.mpy` 文件，那么将存在 `sys.implementation._mpy` 字段，并返回一个整数，该整数编码了版本（低 8 位）、功能和原生架构。

尝试导入未通过前四项测试之一的 `.mpy` 文件时，会引发 `ValueError('incompatible .mpy file')` 异常。

尝试导入未通过原生架构测试（如果包含原生机器码）的 `.mpy` 文件，会引发 `ValueError('incompatible .mpy arch')` 异常。

如果导入 `.mpy` 文件失败，请尝试以下操作：

- 通过执行以下命令，确定你的 MicroPython 系统支持的 `.mpy` 版本和标志：
  ```python
  import sys
  sys_mpy = sys.implementation._mpy
  arch = [None, 'x86', 'x64',
          'armv6', 'armv6m', 'armv7m', 'armv7em', 'armv7emsp', 'armv7emdp',
          'xtensa', 'xtensawin', 'rv32imc'][sys_mpy >> 10]
  print('mpy version:', sys_mpy & 0xff)
  print('mpy sub-version:', sys_mpy >> 8 & 3)
  print('mpy flags:', end='')
  if arch:
      print(' -march=' + arch, end='')
  print()
  ```
- 通过检查文件的前两个字节来验证 `.mpy` 文件的有效性。第一个字节应为大写字母 'M'，第二个字节为版本号，该版本号应与上述系统版本匹配。如果不匹配，请重新生成 `.mpy` 文件。
- 检查系统的 `.mpy` 版本是否与用于生成 `.mpy` 文件的 `mpy-cross` 所输出的版本匹配，可通过 `mpy-cross --version` 查看。如果不匹配，请从 `mpy-cross --version` 所报告的标签（或哈希值）对应的 Git 仓库中重新编译 `mpy-cross`。
- 确保使用了正确的 `mpy-cross` 标志，可通过上述代码找到，或查看所使用系统的 Makefile 中的 `MPY_CROSS_FLAGS` 变量。


以下表格显示了 MicroPython 版本与 `.mpy` 版本的对应关系：

| MicroPython 版本       | .mpy 版本 |
|-----------------------|-----------|
| v1.23.0 及以上         | 6.3       |
| v1.22.x               | 6.2       |
| v1.20 - v1.21.0       | 6.1       |
| v1.19.x               | 6         |
| v1.12 - v1.18         | 5         |
| v1.11                 | 4         |
| v1.9.3 - v1.10        | 3         |
| v1.9 - v1.9.2         | 2         |
| v1.5.1 - v1.8.7       | 0         |


为完整起见，下表显示了 `.mpy` 版本发生更改时 MicroPython 主仓库的 Git 提交记录：

| .mpy 版本变更 | Git 提交哈希                             |
|--------------|-----------------------------------------|
| 6.2 到 6.3   | bdbc869f9ea200c0d28b2bc7bfb60acd9d884e1b |
| 6.1 到 6.2   | 6967ff3c581a66f73e9f3d78975f47528db39980 |
| 6 到 6.1     | d94141e1473aebae0d3c63aeaa8397651ad6fa01 |
| 5 到 6       | f2040bfc7ee033e48acef9f289790f3b4e6b74e5 |
| 4 到 5       | 5716c5cf65e9b2cb46c2906f40302401bdd27517 |
| 3 到 4       | 9a5f92ea72754c01cc03e5efcdfe94021120531e |
| 2 到 3       | ff93fd4f50321c6190e1659b19e64fef3045a484 |
| 1 到 2       | dd11af209d226b7d18d5148b239662e30ed60bad |
| 0 到 1       | 6a11048af1d01c78bdacddadd1b72dc7ba7c6478 |
| 初始版本 0   | d8c834c95d506db979ec871417de90b7951edc30 |


## MicroPython .mpy文件的二进制编码详解

MicroPython的`.mpy`文件是一种二进制容器格式，其中的代码对象（字节码和原生机器码）以嵌套层次结构存储。外层模块的代码先存储，随后是其下属代码元素。每个下属元素可能还有更深层次的子元素，例如类包含的方法、函数中定义的 lambda 表达式或推导式等。为在保持文件小巧的同时支持大范围的数值表示，`.mpy`文件在许多地方采用了**可变编码无符号整数（vuint）** 的概念。与 UTF-8 编码类似，这种编码方式每字节存储7位有效信息，如果后续还有字节，则将第8位（最高位，MSB）设为1。无符号整数的各个位在 vuint 中以**最低有效位（LSB）优先**的形式存储。

`.mpy`文件的顶层结构包含三部分：
- 头部（Header）
- 全局qstr表和常量表
- 模块外层作用域的原始代码。当 .mpy 文件被导入时，这个外层作用域会被执行。

可通过 `mpy-tool.py` 工具检查 `.mpy` 文件内容（从MicroPython主仓库根目录运行）：  
```bash
$ ./tools/mpy-tool.py -xd myfile.mpy
```  


### 头部（Header）  

`.mpy` 文件的头部由 4 个字节组成，结构如下：  

| 大小（字节） | 字段 |
|--------------|------|
| byte | 固定值`0x4d`（对应ASCII字符'M'） |
| byte | `.mpy`格式的主版本号 |
| byte | 存储原生架构信息和次版本号（旧版本中为功能标志） |
| byte | 表示小整数（small int）的位数 |


### 全局 qstr 和常量表  

一个 `.mpy` 文件包含一个 qstr 表和一个常量对象表。这些表对 `.mpy` 文件而言是全局的，会被所有嵌套的原始代码对象引用。qstr 表用于将 `.mpy` 文件内部的 qstr 编号（文件内部使用）映射到该 `.mpy` 文件被导入后运行时环境中已解析的 qstr 编号。这一机制将 `.mpy` 文件与它所运行的系统其他部分关联起来。常量对象表中则填充了该 `.mpy` 文件所需的所有常量对象的引用。

| 大小（字节） | 字段 |
|--------------|------|
| vuint | qstr 的数量 |
| vuint | 常量对象的数量 |
| …… | qstr数据 |
| …… | 编码的常量对象 |


### 原始代码元素（Raw Code Elements）  

一个原始代码（raw-code）元素包含代码，既可以是字节码，也可以是原生机器码。其内容包括：

| 大小（字节） | 字段 |
|--------------|------|
| vuint | 用于表示代码类型、大小以及是否包含子原始代码元素 |
| …… | 代码（字节码或机器码） |
| vuint | 子原始代码元素的数量（仅在数量非零时存在） |
| …… | 子原始代码元素 |

原始代码元素中的第一个 vuint（可变编码无符号整数）包含以下信息：
- 最低两位：表示该元素中存储的代码类型  
- 第三位最低有效位：表示该原始代码是否包含子元素  
- 其余位：表示后续代码的长度（即需要为其分配的RAM大小）  

该 vuint 之后是代码本身。除非代码类型是带重定位的 viper 代码，否则此代码为常量数据，无需修改。  

如果该原始代码包含子元素（由第一个 vuint 中的对应位标识），则代码之后会有一个 vuint，用于记录子原始代码元素的数量。  

最后，所有子原始代码元素会以递归方式存储。
