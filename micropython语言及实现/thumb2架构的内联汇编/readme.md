# Thumb2 架构的内联汇编

在这里假定读者对汇编语言编程有一定了解，应在学习教程之后阅读。有关指令集的详细描述，请参考下文提到的《架构参考手册》。内联汇编支持此处所述的 ARM Thumb-2 指令集的一个子集。其语法尽量贴近上述 ARM 手册中定义的语法，并转换为 Python 函数调用的形式。

除非另有说明，否则指令均对 32 位有符号整数数据进行操作。大多数受支持的指令仅对寄存器 R0-R7 进行操作：若支持 R8-R15，会对此进行说明。从函数返回前，必须将寄存器 R8-R12 恢复至其初始值。寄存器 R13-R15 分别为链接寄存器、栈指针和程序计数器。


## 文档约定

在可能的情况下，每条指令的行为都用Python来描述，例如：

- add(Rd, Rn, Rm)  `Rd = Rn + Rm`

这样可以在 Python 中演示指令的效果。在某些情况下，这是不可能的，因为 Python 不支持诸如间接寻址之类的概念。这种情况下所使用的伪代码会在相关页面中进行说明。


## 指令类别

以下各节详细介绍了 MicroPython 所支持的 ARM Thumb-2 指令集的子集。

### 寄存器移动指令

#### 文档约定

符号说明：`Rd`、`Rn` 表示 ARM 寄存器 R0-R15。`immN` 表示宽度为 N 位的立即数。这些指令会影响条件标志位。

#### 寄存器移动

当使用立即数时，这些立即数会被零扩展至 32 位。因此，`mov(R0, 0xff)`会将 R0 设置为 255。

- mov(Rd, imm8)  `Rd = imm8`
- mov(Rd, Rn)  `Rd = Rn`
- movw(Rd, imm16)  `Rd = imm16`
- movt(Rd, imm16)  `Rd = (Rd & 0xffff) | (imm16 << 16)`
  movt将立即数写入目标寄存器的高半字。它不会影响低半字的内容。

- movwt(Rd, imm32)  `Rd = imm32`
  movwt是一条伪指令：MicroPython汇编器会生成一条movw指令，后跟一条movt指令，以将32位值移入Rd。


### 从内存加载寄存器

#### 文档约定

符号说明：除非另有说明，`Rt`、`Rn` 表示 ARM 寄存器 R0-R7。`immN` 表示宽度为 N 位的立即数，因此 `imm5` 的取值范围限定为 0-31。`[Rn + immN]` 是通过将 Rn 与偏移量 `immN` 相加得到的内存地址所存储的内容。偏移量以字节为单位。这些指令会影响条件标志位。

#### 寄存器加载

- ldr(Rt, [Rn, imm7])  `Rt = [Rn + imm7]` 加载一个 32 位字
- ldrb(Rt, [Rn, imm5])  `Rt = [Rn + imm5]` 加载一个字节
- ldrh(Rt, [Rn, imm6])  `Rt = [Rn + imm6]` 加载一个 16 位半字
  当加载一个字节或半字时，会将其零扩展至 32 位。

指定的立即数偏移量以字节为单位。因此，对于 `ldr` 指令，7 位的值使得能够访问 32 位字对齐的值，最大偏移量为 31 个字。对于 `ldrh` 指令，6 位的值使得能够访问 16 位半字对齐的值，最大偏移量为 31 个半字。


### 将寄存器存储到内存

#### 文档约定

符号说明：除非另有说明，`Rt`、`Rn`表示 ARM 寄存器 R0-R7。`immN` 表示宽度为 N 位的立即数，因此 `imm5` 的取值范围限定为 0-31。`[Rn + imm5]` 是通过将 Rn 与偏移量 `imm5` 相加得到的内存地址所存储的内容。偏移量以字节为单位。这些指令不会影响条件标志位。

#### 寄存器存储

- str(Rt, [Rn, imm7]) `[Rn + imm7] = Rt` 存储一个 32 位字
- strb(Rt, [Rn, imm5]) `[Rn + imm5] = Rt` 存储一个字节（b0-b7）
- strh(Rt, [Rn, imm6]) `[Rn + imm6] = Rt` 存储一个 16 位半字（b0-b15）

指定的立即数偏移量以字节为单位。因此，对于`str`指令，7 位的值使得能够访问 32 位字对齐的值，最大偏移量为 31 个字。对于`strh`指令，6 位的值使得能够访问 16 位半字对齐的值，最大偏移量为 31 个半字。


### 逻辑与位运算指令

#### 文档约定

符号说明：除非在特殊指令中可能使用 R0-R15，否则`Rd`、`Rn`表示 ARM 寄存器 R0-R7。`Rn<a-b>`表示其内容必须在 `a <= contents <= b` 范围内的 ARM 寄存器。对于带有两个寄存器参数的指令，允许这两个寄存器相同。例如，以下指令会将 R0 清零（对应 Python 中的`R0 ^= R0`），无论其初始内容如何：

- eor(r0, r0)

除非另有说明，否则这些指令会影响条件标志位。

#### 逻辑指令

- and_(Rd, Rn) `Rd &= Rn`（按位与运算）
- orr(Rd, Rn) `Rd |= Rn`（按位或运算）
- eor(Rd, Rn) `Rd ^= Rn`（按位异或运算）
- mvn(Rd, Rn) `Rd = Rn ^ 0xffffffff`，即Rd等于Rn的反码
- bic(Rd, Rn) `Rd &= ~Rn`（使用Rn中的掩码清除Rd的位）

注意此处使用“and_”而非“and”，因为“and”是 Python 中的保留关键字。

#### 移位与旋转指令

- lsl(Rd, Rn<0-31>) `Rd <<= Rn`（逻辑左移）
- lsr(Rd, Rn<1-32>) `Rd = (Rd & 0xffffffff) >> Rn`（逻辑右移）
- asr(Rd, Rn<1-32>) `Rd >>= Rn`（算术右移）
- ror(Rd, Rn<1-31>) `Rd = rotate_right(Rd, Rn)`（Rd向右旋转Rn位）

例如，旋转3位的工作方式如下：如果 Rd 最初包含位`b31、b30……b0`，旋转后将包含`b2、b1、b0、b31、b30……b3`。

#### 特殊指令

这些指令不影响条件码。

- clz(Rd, Rn) `Rd = count_leading_zeros(Rn)`（前导零计数）
  count_leading_zeros(Rn)返回Rn中第一个二进制1位之前的二进制零位的数量。

- rbit(Rd, Rn) `Rd = bit_reverse(Rn)`（位反转）
  bit_reverse(Rn) 返回 Rn 内容的位反转结果。如果 Rn 包含位`b31、b30……b0`，则 Rd 将被设置为`b0、b1、b2……b31`。

可以先执行位反转，再执行 clz 指令来计算尾随零的数量。


### 算术指令

#### 文档约定

符号说明：`Rd`、`Rm`、`Rn`表示 ARM 寄存器 R0-R7。`immN`表示宽度为 N 位的立即数，例如`imm8`、`imm3`。`carry`表示进位条件标志，`not(carry)`表示其补码。对于具有多个寄存器参数的指令，允许部分寄存器相同。例如，以下指令会将 R0 的内容与自身相加，并将结果存入 R0：

- add(r0, r0, r0)

除非另有说明，否则算术指令会影响条件标志位。

#### 加法

- add(Rdn, imm8) `Rdn = Rdn + imm8`
- add(Rd, Rn, imm3) `Rd = Rn + imm3`
- add(Rd, Rn, Rm) `Rd = Rn + Rm`
- adc(Rd, Rn) `Rd = Rd + Rn + carry`（带进位加法）

#### 减法

- sub(Rdn, imm8) `Rdn = Rdn - imm8`
- sub(Rd, Rn, imm3) `Rd = Rn - imm3`
- sub(Rd, Rn, Rm) `Rd = Rn - Rm`
- sbc(Rd, Rn) `Rd = Rd - Rn - not(carry)`（带借位减法）

#### 取反

- neg(Rd, Rn) `Rd = -Rn`（Rn的相反数）

#### 乘法和除法

- mul(Rd, Rn) `Rd = Rd * Rn`（乘法）
  该指令产生 32 位结果，溢出部分会丢失。根据操作数的定义，结果可被视为有符号数或无符号数。

- sdiv(Rd, Rn, Rm) `Rd = Rn / Rm`（有符号除法）
- udiv(Rd, Rn, Rm) `Rd = Rn / Rm`（无符号除法）
  这些函数分别执行有符号除法和无符号除法。条件标志位不受影响。


### 比较指令

这些指令对两个操作数执行算术或逻辑运算，丢弃运算结果但会设置条件标志位。通常，这些指令用于在执行条件分支之前测试数据值而不改变它们。

#### 文档约定

符号说明：`Rd`、`Rm`、`Rn`表示 ARM 寄存器 R0-R7。`imm8`表示宽度为 8 位的立即数。

#### 应用程序状态寄存器（APSR）

该寄存器包含 4 个比特位，可供条件分支指令测试。通常，一个条件分支会测试多个比特位，例如`bge(LABEL)`。条件码的含义可能取决于算术指令的操作数被视为有符号整数还是无符号整数。因此，`bhi(LABEL)`假设处理的是无符号数，而`bgt(LABEL)`假设处理的是有符号操作数。

#### APSR的比特位

- Z（零标志位）
  如果运算结果为零，或者比较的操作数相等，则设置该标志位。

- N（负标志位）
  如果运算结果为负数，则设置该标志位。

- C（进位标志位）
  当加法运算的结果从最高有效位（MSB）溢出时，会设置进位标志位，例如0x80000000与0x80000000相加。由于补码算术的特性，在减法运算中该行为会反转，进位位为0表示产生了借位。因此，0x10减0x01的运算会以0x10加0xffffffff的方式执行，这会设置进位标志位。

- V（溢出标志位）
  如果将运算结果视为补码数时，其符号与操作数的符号不匹配，则设置溢出标志位。例如，1与0x7fffffff相加会设置溢出标志位，因为结果（0x80000000）作为补码整数来看是负数。请注意，在这种情况下，进位标志位不会被设置。

#### 比较指令

这些指令会设置应用程序状态寄存器（APSR）的N（负）、Z（零）、C（进位）和V（溢出）标志位。

- cmp(Rn, imm8) 执行 `Rn - imm8` 的运算
- cmp(Rn, Rm) 执行 `Rn - Rm` 的运算
- cmn(Rn, Rm) 执行 `Rn + Rm` 的运算
- tst(Rn, Rm) 执行 `Rn & Rm` 的运算

#### 条件执行

`it`和`ite`指令提供了一种条件执行后续 1 到 4 条指令的方式，无需使用标签。

- `it(<condition>)` 若满足则执行（If then）
  如果<condition>为真，则执行下一条指令：
  ```
  cmp(r0, r1)
  it(eq)
  mov(r0, 100)  # 当r0 == r1时执行
  # 在此处继续执行
  ```

- `ite(<condition>)` 若满足则执行，否则执行另一指令（If then else）
  如果<condition>为真，则执行下一条指令；否则，执行再下一条指令。例如：
  ```
  cmp(r0, r1)
  ite(eq)
  mov(r0, 100)  # 当r0 == r1时执行
  mov(r0, 200)  # 当r0 != r1时执行
  # 在此处继续执行
  ```
  这可以扩展为控制后续最多4条指令的执行：it[x[y[z]]]，其中x、y、z可以是t或e；例如itt、itee、itete、ittte、itttt、iteee等。


### 分支指令

这些指令会使程序执行跳转到目标位置，目标位置通常由标签（参见标签汇编伪指令）指定。条件分支以及`it`和`ite`指令会检测应用程序状态寄存器（APSR）中的N（负）、Z（零）、C（进位）和V（溢出）标志位，以确定是否执行分支。

大多数公开的汇编指令（包括移动操作）都会设置这些标志位，但也有专门的比较指令用于测试值。

关于条件标志位含义的更多细节，可参见描述比较函数的章节。

#### 文档约定

符号说明：`Rm`表示 ARM 寄存器 R0-R15。`LABEL`表示通过`label()`汇编伪指令定义的标签。`<condition>`表示以下条件说明符之一：
- `eq` 相等（结果为零）
- `ne` 不相等
- `cs` 进位标志置位
- `cc` 进位标志清零
- `mi` 负数（结果为负）
- `pl` 正数（结果为正）
- `vs` 溢出标志置位
- `vc` 溢出标志清零
- `hi` 大于（无符号比较）
- `ls` 小于等于（无符号比较）
- `ge` 大于等于（有符号比较）
- `lt` 小于（有符号比较）
- `gt` 大于（有符号比较）
- `le` 小于等于（有符号比较）

#### 跳转到标签

- `b(LABEL)` 无条件分支
- `beq(LABEL)` 相等时分支
- `bne(LABEL)` 不相等时分支
- `bge(LABEL)` 大于等于时分支
- `bgt(LABEL)` 大于时分支
- `blt(LABEL)` 小于时分支（有符号）
- `ble(LABEL)` 小于等于时分支（有符号）
- `bcs(LABEL)` 进位标志置位时分支
- `bcc(LABEL)` 进位标志清零时分支
- `bmi(LABEL)` 为负数时分支
- `bpl(LABEL)` 为正数时分支
- `bvs(LABEL)` 溢出标志置位时分支
- `bvc(LABEL)` 溢出标志清零时分支
- `bhi(LABEL)` 更高时分支（无符号）
- `bls(LABEL)` 更低或相等时分支（无符号）

#### 长分支

上述分支指令生成的代码使用固定的位宽来指定分支目标，该目标是相对于程序计数器（PC）的。因此，在长程序中，如果分支指令与其目标位置相距较远，汇编器会产生“分支超出范围”错误。这可以通过“宽”变体来解决，例如：

- `beq_w(LABEL)` 相等时长分支

长分支使用4个字节来编码指令（标准分支指令为2个字节）。

#### 子程序（函数）

进入子程序时，处理器会将返回地址存储在寄存器 r14 中，该寄存器也称为链接寄存器（lr）。从子程序调用后返回至下一条指令，是通过从链接寄存器更新程序计数器（r15 或 pc）来实现的。以下指令用于处理这一过程：

- `bl(LABEL)`

将执行转移到LABEL之后的指令，并将返回地址存储在链接寄存器（r14）中。

- `bx(Rm)` 跳转到Rm所指定的地址。

通常，执行`bx(lr)`来从子程序返回。对于嵌套子程序，在执行内部子程序调用之前，必须保存外部作用域的链接寄存器（通常保存在栈上）。


### 入栈和出栈

#### 文档约定

`push()`和`pop()`指令接受的参数是一个寄存器集合，该集合包含通用寄存器 R0-R12 和链接寄存器（lr或R14）中的一部分，也可能包含全部。与任何 Python 集合一样，寄存器的指定顺序无关紧要。因此，在以下示例中，pop() 指令会将 R1、R7 和 R8 恢复到 push() 之前的内容：

- `push({r1, r8, r7})` 将三个寄存器保存到栈上。
- `pop({r7, r1, r8})` 恢复这三个寄存器

#### 栈操作

- `push({regset})` 将一组寄存器压入栈中
- `pop({regset})` 从栈中恢复一组寄存器


### 其他指令

- `nop()` 空操作（无操作）。
- `wfi()` 使处理器进入低功耗状态暂停执行，直到中断发生。
- `cpsid(flags)` 设置优先级屏蔽寄存器——禁用中断。
- `cpsie(flags)` 清除优先级屏蔽寄存器——启用中断。
- `mrs(Rd, special_reg) Rd = special_reg` 将特殊寄存器的值复制到通用寄存器。特殊寄存器可以是IPSR（中断状态寄存器）或BASEPRI（基本优先级寄存器）。IPSR用于确定正在处理的中断的异常编号。如果没有正在处理的中断，它的值为零。

目前，`cpsie()`和`cpsid()`函数仅部分实现。它们需要flags参数但会忽略该参数，仅用作启用和禁用中断的方式。


### 浮点指令

这些指令支持使用 ARM 浮点协处理器（在配备该协处理器的平台上，如Pyboard）。浮点单元（FPU）有 32 个寄存器，称为 s0-s31，每个寄存器可存储一个单精度浮点数。通过 `vmov` 指令，数据可以在 FPU 寄存器和 ARM 核心寄存器之间传递。

请注意，MicroPython 不支持向汇编函数传递浮点数，也不能将浮点数放入 r0 寄存器并期望得到合理结果。有两种方法可以解决这个问题：第一种是使用数组，第二种是传递和/或返回整数，并在代码中进行与浮点数之间的转换。

#### 文档约定

符号说明：`Sd`、`Sm`、`Sn`表示 FPU 寄存器，`Rd`、`Rm`、`Rn`表示 ARM 核心寄存器。后者可以是任何 ARM 核心寄存器，但寄存器 R13-R15 在这种情况下不太适用。

#### 算术运算

- vadd(Sd, Sn, Sm) `Sd = Sn + Sm`（加法）
- vsub(Sd, Sn, Sm) `Sd = Sn - Sm`（减法）
- vneg(Sd, Sm) `Sd = -Sm`（取反）
- vmul(Sd, Sn, Sm) `Sd = Sn * Sm`（乘法）
- vdiv(Sd, Sn, Sm) `Sd = Sn / Sm`（除法）
- vsqrt(Sd, Sm) `Sd = sqrt(Sm)`（平方根）

寄存器可以相同：`vmul(S0, S0, S0)`将执行`S0 = S0 * S0`的操作。

#### ARM 核心寄存器与 FPU 寄存器之间的移动

- vmov(Sd, Rm) `Sd = Rm`（将 ARM 核心寄存器的值移至 FPU 寄存器）
- vmov(Rd, Sm) `Rd = Sm`（将 FPU 寄存器的值移至 ARM 核心寄存器）

FPU 有一个称为 FPSCR 的寄存器，类似于 ARM 核心的 APSR，用于存储条件码和其他数据。以下指令提供对该寄存器的访问：

- `vmrs(APSR_nzcv, FPSCR)`

将浮点的N、Z、C、V标志移至APSR的N、Z、C、V标志。

这一步通常在FPU比较等指令之后执行，以便汇编代码能够测试条件码。以下是该指令的更通用形式：

- vmrs(Rd, FPSCR) `Rd = FPSCR`（将FPSCR的值移至ARM核心寄存器）

#### FPU寄存器与内存之间的移动

- vldr(Sd, [Rn, offset]) `Sd = [Rn + offset]`（从内存加载值至FPU寄存器）
- vstr(Sd, [Rn, offset]) `[Rn + offset] = Sd`（将FPU寄存器的值存储至内存）

其中`[Rn + offset]`表示通过将 Rn 与偏移量相加得到的内存地址，偏移量以字节为单位。

由于每个浮点值占用一个 32 位字，因此在访问浮点数组时，偏移量必须始终是 4 字节的倍数。

#### 数据比较

- `vcmp(Sd, Sm)`
  比较 Sd 和 Sm 中的值，并设置 FPU 的N、Z、C、V标志。这一步之后通常会执行`vmrs(APSR_nzcv, FPSCR)`，以便能够测试比较结果。

#### 整数与浮点数之间的转换

- vcvt_f32_s32(Sd, Sm) `Sd = float(Sm)`（将32位有符号整数转换为32位浮点数）
- vcvt_s32_f32(Sd, Sm) `Sd = int(Sm)`（将32位浮点数转换为32位有符号整数）


### 汇编伪指令

#### 标签

- `label(INNER1)`
  此伪指令定义一个供分支指令使用的标签。因此，在代码的其他位置使用`b(INNER1)`会使程序执行跳转到该标签伪指令之后的指令处继续执行。

#### 定义内联数据

以下汇编伪指令有助于在汇编代码块中嵌入数据。

- `data(size, d0, d1 … dn)`
  data伪指令在内存中创建一个包含 n 个数据值的数组。第一个参数指定后续各参数的大小（以字节为单位）。因此，下面第一条语句会使汇编器将 3 个字节（值分别为 2、3、4）存入连续的内存位置，而第二条语句会使汇编器生成两个 4 字节的字。
  ```
  data(1, 2, 3, 4)
  data(4, 2, 100000)
  ```
  长度超过 1 字节的数据值在内存中以小端格式存储。

- `align(nBytes)`
  将后续指令对齐到 nBytes 的边界。ARM Thumb-2 指令必须按 2 字节对齐，因此建议在 `data` 伪指令之后、任何后续代码之前使用 `align(2)`。这能确保无论数据数组的大小如何，代码都能正常运行。


## 使用示例

本节提供了更多代码示例以及关于汇编器使用的提示。

### 提示与技巧

以下是一些内联汇编器的使用示例，以及有关如何规避其局限性的信息。在本文档中，“汇编函数”指的是在 Python 中使用`@micropython.asm_thumb`装饰器声明的函数，而“子程序”指的是在汇编函数内部调用的汇编代码。

### 代码分支和子程序

需要注意的是，标签是汇编函数局部的。目前，无法从一个函数中调用另一个函数中定义的子程序。

调用子程序时，需使用`bl(LABEL)`指令。该指令将控制权转移到`label(LABEL)`伪指令后的指令，并将返回地址存储在链接寄存器（lr 或 r14）中。返回时，使用`bx(lr)`指令，使程序执行继续从子程序调用后的指令开始。这种机制意味着，如果一个子程序要调用另一个子程序，它必须在调用前保存链接寄存器，并在结束前恢复该寄存器。

下面这个刻意设计的示例展示了函数调用。注意，在开始处需要分支绕过所有子程序调用：子程序以`bx(lr)`结束执行，而外部函数则以 Python 函数的风格“自然结束”。

```python
@micropython.asm_thumb
def quad(r0):
    b(START)
    label(DOUBLE)
    add(r0, r0, r0)
    bx(lr)
    label(START)
    bl(DOUBLE)
    bl(DOUBLE)

print(quad(10))
```

下面的代码示例演示了嵌套（递归）调用：经典的斐波那契数列。在这里，在进行递归调用之前，链接寄存器会与程序逻辑需要保留的其他寄存器一起被保存。

```python
@micropython.asm_thumb
def fib(r0):
    b(START)
    label(DOFIB)
    push({r1, r2, lr})
    cmp(r0, 1)
    ble(FIBDONE)
    sub(r0, 1)
    mov(r2, r0)  # r2 = n - 1
    bl(DOFIB)
    mov(r1, r0)  # r1 = fib(n - 1)
    sub(r0, r2, 1)
    bl(DOFIB)    # r0 = fib(n - 2)
    add(r0, r0, r1)
    label(FIBDONE)
    pop({r1, r2, lr})
    bx(lr)
    label(START)
    bl(DOFIB)

for n in range(10):
    print(fib(n))
```

### 参数传递与返回值

汇编函数可以支持 0 到 3 个参数（如果使用参数），这些参数必须命名为 `r0`、`r1` 和 `r2`。当代码执行时，寄存器将被初始化为这些值。

通过这种方式可以传递的数据类型为整数和内存地址。在当前固件中，所有可能的 32 位值都可以被传递和返回。如果返回值的最高位可能被设置，应使用 Python 类型提示，使 MicroPython 能够确定该值应被解释为有符号整数还是无符号整数：类型分别为 `int` 或 `uint`。

```python
@micropython.asm_thumb
def uadd(r0, r1) -> uint:
    add(r0, r0, r1)
```

`hex(uadd(0x40000000, 0x40000000))` 将返回 `0x80000000`，这展示了在第 30 位和第 31 位不同的情况下整数的传递和返回。

参数数量和返回值数量的限制可以通过`array`模块来克服，该模块允许访问任意数量、任意类型的值。


#### 多个参数

如果将一个 Python 整数数组作为参数传递给汇编函数，该函数将接收一组连续整数的地址。因此，多个参数可以作为单个数组的元素进行传递。同样，函数可以通过将多个值分配给数组元素来返回这些值。汇编函数无法确定数组的长度，因此需要将数组长度传递给该函数。

数组的这种用法可以扩展到使用三个以上的数组。这通过间接寻址来实现：`uctypes`模块支持`addressof()`函数，该函数会返回作为其参数传递的数组的地址。因此，你可以在一个整数数组中存入其他数组的地址：

```python
from uctypes import addressof

@micropython.asm_thumb
def getindirect(r0):
    ldr(r0, [r0, 0])  # 从传递的数组中加载另一个数组的地址
    ldr(r0, [r0, 4])  # 返回间接数组的第1个元素（24）

def testindirect():
    a = array.array('i', [23, 24])
    b = array.array('i', [0, 0])
    b[0] = addressof(a)
    print(getindirect(b))
```

#### 非整数数据类型

这些可以通过适当数据类型的数组来处理。例如，单精度浮点数据可以按如下方式处理。此代码示例接收一个浮点数数组，并将其内容替换为各自的平方。

```python
from array import array

@micropython.asm_thumb
def square(r0, r1):
    label(LOOP)
    vldr(s0, [r0, 0])
    vmul(s0, s0, s0)
    vstr(s0, [r0, 0])
    add(r0, 4)
    sub(r1, 1)
    bgt(LOOP)

a = array('f', (x for x in range(10)))
square(a, len(a))
print(a)
```

uctypes 模块支持使用除简单数组之外的数据结构。它能将 Python 数据结构映射到一个 `bytearray` 实例上，然后该实例可被传递给汇编函数。


### 命名常量

通过使用命名常量而非在代码中随意使用数字，可以使汇编代码更具可读性和可维护性。具体实现方式如下：

```python
MYDATA = const(33)

@micropython.asm_thumb
def foo():
    mov(r0, MYDATA)
```

const() 构造会让 MicroPython 在编译时将变量名替换为其对应的值。如果在外部 Python 作用域中声明常量，那么这些常量可以在多个汇编函数之间共享，也可以与 Python 代码共享。


### 汇编代码作为类方法

MicroPython 会将对象实例的地址作为第一个参数传递给类方法。这对汇编函数通常没什么用处。可以通过将函数声明为静态方法来避免这种情况，如下所示：

```python
class foo:
    @staticmethod
    @micropython.asm_thumb
    def bar(r0):
        add(r0, r0, r0)
```


### 不支持的指令的使用

这些指令可以使用如下所示的 data 语句进行编码。虽然 `push()` 和 `pop()` 是受支持的，但下面的示例说明了其原理。必要的机器码可以在《ARM v7-M 架构参考手册》中找到。

请注意，诸如以下 data 调用的第一个参数：

```python
data(2, 0xe92d, 0x0f00)  # push r8,r9,r10,r11
```

表示后续的每个参数都是一个 2 字节的量。


### 克服MicroPython的整数限制

Pyboard芯片包含一个CRC生成器。在MicroPython中使用它会遇到一个问题：其返回值涵盖了所有32位数值，而MicroPython中的小整数不能在第30位和第31位上有不同的值。以下代码解决了这一限制，它使用汇编将结果存入数组，并通过Python代码将结果强制转换为任意精度的无符号整数。

```python
from array import array
import stm

def enable_crc():
    stm.mem32[stm.RCC + stm.RCC_AHB1ENR] |= 0x1000

def reset_crc():
    stm.mem32[stm.CRC + stm.CRC_CR] = 1

@micropython.asm_thumb
def getval(r0, r1):
    movwt(r3, stm.CRC + stm.CRC_DR)
    str(r1, [r3, 0])
    ldr(r2, [r3, 0])
    str(r2, [r0, 0])

def getcrc(value):
    a = array('i', [0])
    getval(a, value)
    return a[0] & 0xffffffff  # 强制转换为任意精度

enable_crc()
reset_crc()
for x in range(20):
    print(hex(getcrc(0)))
```
